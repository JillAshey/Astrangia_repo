---
title: "More network stuff"
author: "Jill Ashey"
date: "2026-01-26"
output: html_document
---

# Network analysis of mRNA-miRNA interactions

Load packages
```{r, include=F}
library(tidyverse)
library(DESeq2)
library(igraph)
library(corrplot)
library(pheatmap)
library(ggraph)
library(tidygraph)
library(patchwork)
library(RColorBrewer)
library(ggalluvial)
library(bipartite)
library(parallel)
library(plotly)
library(broom)
library(topGO)
```

## Read in data and normalize 

Read in metadata 
```{r}
metadata <- read.csv("../data/Molecular/RNA_metadata.csv")

# Remove AST-1105 -- did not sequence well 
metadata <- metadata %>%
  filter(!ID == "AST-1105") %>%
  rename(sample = ID, timepoint = Timepoint, treatment = Treatment)
```

Load mRNA counts and normalize 
```{r, include=F}
mrna_counts <- read_csv("../output/Molecular/mRNA/filtered_gene_counts.csv")
mrna_counts_df <- as.data.frame(mrna_counts)
rownames(mrna_counts_df) <- mrna_counts_df$...1
mrna_counts_df$...1 <- NULL

# Remove AST-1105 -- did not sequence well 
mrna_counts_df <- mrna_counts_df %>%
  select(-"AST-1105")

# Reorder count matrices to match metadata sample order
mrna_counts <- mrna_counts_df[, metadata$sample]

# Normalize 
dds_mrna <- DESeqDataSetFromMatrix(
  countData = mrna_counts_df,
  colData = metadata,
  design = ~1)
vsd_mrna <- vst(dds_mrna, blind = FALSE)
mrna_norm <- assay(vsd_mrna)
```

Load miRNA counts and normalize 
```{r, include=F}
mirna_counts <- read.csv("../output/Molecular/smRNA/shortstack/putative_miRNA_counts.csv") # AST-1105 already removed from the df 
mirna_counts_df <- as.data.frame(mirna_counts)
rownames(mirna_counts_df) <- mirna_counts_df$X
mirna_counts_df$X <- NULL

# Replace . with - in sample names 
colnames(mirna_counts_df) <- ifelse(
  str_starts(colnames(mirna_counts_df), "AST"),
  gsub("\\.", "-", colnames(mirna_counts_df)),
  colnames(mirna_counts_df))

# Reorder count matrices to match metadata sample order
mirna_counts <- mirna_counts_df[, metadata$sample]

# Normalize 
dds_mirna <- DESeqDataSetFromMatrix(
  countData = mirna_counts_df,
  colData = metadata,
  design = ~1)
vsd_mirna <- varianceStabilizingTransformation(dds_mirna, blind = FALSE)
mirna_norm <- assay(vsd_mirna)
```

## Read in interaction data 

Read in miranda data - 1kb 3'UTR binding 
```{r}
miranda_3utr <- read.delim("../output/Molecular/interactions/miranda_strict_all_1kb_apoc_shortstack_parsed.txt", header = F)
colnames(miranda_3utr) <- c("miRNA", "mRNA", "score", "energy", "query_start_end", "subject_start_end", "total_bp_shared", "query_similar", "subject_similar")

# Format miranda df
miranda_3utr$miRNA <- sub("^>", "", miranda_3utr$miRNA)  # Remove leading ">"
miranda_3utr$miRNA <- sub("\\..*", "", miranda_3utr$miRNA)  # Remove everything from the first period onwards
miranda_3utr$mRNA <- sub(";.*", "", miranda_3utr$mRNA)  # Remove everything from "::" onwards
miranda_3utr$mRNA <- sub("ID=", "", miranda_3utr$mRNA)  # Remove everything from "::" onwards

dim(miranda_3utr)
length(unique(miranda_3utr$miRNA))
length(unique(miranda_3utr$mRNA))

# Calculate length of binding 
miranda_3utr <- miranda_3utr %>%
  separate(query_start_end, into = c("start", "end"), sep = " ", convert = TRUE) %>%
  mutate(interaction_length = end - start)
miranda_3utr$binding_type <- "3'UTR"
```

Read in miranda data - entire mRNA binding
```{r}
miranda_mrna <- read.delim("~/Desktop/PutnamLab/Astrangia/Molecular/miranda_strict_all_mrna_apoc_shortstack_parsed.txt", header = F)
colnames(miranda_mrna) <- c("miRNA", "mRNA", "score", "energy", "query_start_end", "subject_start_end", "total_bp_shared", "query_similar", "subject_similar")

# Format miranda df 
miranda_mrna$miRNA <- sub("^>", "", miranda_mrna$miRNA)  # Remove leading ">"
miranda_mrna$miRNA <- sub("\\..*", "", miranda_mrna$miRNA)  # Remove everything from the first period onwards
miranda_mrna$mRNA <- sub(";.*", "", miranda_mrna$mRNA)  # Remove everything from "::" onwards
miranda_mrna$mRNA <- sub("ID=", "", miranda_mrna$mRNA)  # Remove everything from "::" onwards
miranda_mrna$mRNA <- sub("model", "TU", miranda_mrna$mRNA)  # Remove everything from "::" onwards

dim(miranda_mrna)
length(unique(miranda_mrna$miRNA))
length(unique(miranda_mrna$mRNA))

# Calculate length of binding 
miranda_mrna <- miranda_mrna %>%
  separate(query_start_end, into = c("start", "end"), sep = " ", convert = TRUE) %>%
  mutate(interaction_length = end - start) 
miranda_mrna$binding_type <- "CDS"
```

Bind miranda dfs and filter so that interaction length must be at least 13 bp
```{r}
miranda_data <- rbind(miranda_3utr, miranda_mrna)

# Filter interaction length 
miranda_data <- miranda_data %>%
  filter(interaction_length >= 13) 
miranda_data <- unique(miranda_data)
```

Check data 
```{r}
# Data dimensions
cat("mRNA genes:", nrow(mrna_counts_df), "\n")
cat("mRNA samples:", ncol(mrna_counts_df), "\n")
cat("miRNA:", nrow(mirna_counts_df), "\n")
cat("miRNA samples:", ncol(mirna_counts_df), "\n")
cat("Metadata rows:", nrow(metadata), "\n")
cat("Predicted interactions:", nrow(miranda_data), "\n\n")

# Check that sample names match
cat("Samples in mRNA data:", paste(colnames(mrna_counts_df), collapse = ", "), "...\n")
cat("Samples in miRNA data:", paste(colnames(mirna_counts_df), collapse = ", "), "...\n")
cat("Samples in metadata:", paste(metadata$sample), collapse = ", ", "...\n\n")

# Check if all samples match
all_match <- all(colnames(mrna_counts_df) == metadata$sample) & 
             all(colnames(mirna_counts_df) == metadata$sample)
cat("Do all samples match? ", all_match, "\n\n")

# Check interaction predictions
cat("Column names in interactions:", paste(colnames(miranda_data), collapse = ", "), "\n")
head(miranda_data)
table(miranda_data$binding_type)
```

## Remove any miRNAs or mRNA not expressed from miranda data 

Some miRNAs and mRNAs were not expressed in our data but interactions were still predicted with these data. Remove the miRNAs and mRNAs not expressed from the interaction data 
```{r}
# Check which genes/miRNAs are missing
mirnas_in_interactions <- unique(miranda_data$miRNA)
mrnas_in_interactions <- unique(miranda_data$mRNA)

mirnas_in_counts <- rownames(mirna_norm)
mrnas_in_counts <- rownames(mrna_norm)

# miRNAs missing
missing_mirnas <- setdiff(mirnas_in_interactions, mirnas_in_counts)
cat("miRNAs in interactions but NOT in expression data:", length(missing_mirnas), "\n")
if (length(missing_mirnas) > 0) {
  cat("Examples:", head(missing_mirnas, 5), "\n")
}

# mRNAs missing
missing_mrnas <- setdiff(mrnas_in_interactions, mrnas_in_counts)
cat("\nmRNAs in interactions but NOT in expression data:", length(missing_mrnas), "\n")
if (length(missing_mrnas) > 0) {
  cat("Examples:", head(missing_mrnas, 5), "\n")
}

# Filter interactions to only include those present in expression data 
miranda_data_filtered <- miranda_data %>%
  filter(miRNA %in% mirnas_in_counts,
         mRNA %in% mrnas_in_counts)

cat("Filtered interactions:", nrow(miranda_data_filtered), "\n")
cat("Removed:", nrow(miranda_data) - nrow(miranda_data_filtered), "interactions\n\n")

# Verify all are present now
cat("Verification:\n")
cat("All miRNAs present?", all(miranda_data_filtered$miRNA %in% mirnas_in_counts), "\n")
cat("All mRNAs present?", all(miranda_data_filtered$mRNA %in% mrnas_in_counts), "\n\n")
```

## Perform correlation analysis 

Correlation time! Using spearman's correlation coefficient because it is non-parametric and robust against outliers.  
```{r}
# Function to calculate correlations for one condition
calculate_condition_correlations <- function(mrna_data, mirna_data, 
                                             interactions_df,
                                             metadata, 
                                             timepoint_val, 
                                             treatment_val,
                                             min_cor_threshold = 0.3) {
  
  cat("Processing:", timepoint_val, "-", treatment_val, "\n")
  
  # Get samples for this condition
  samples <- metadata %>% 
    dplyr::filter(timepoint == timepoint_val, treatment == treatment_val) %>% 
    dplyr::pull(sample)
  
  n_samples <- length(samples)
  cat("  N samples:", n_samples, "\n")
  
  # Subset data to these samples
  mrna_subset <- mrna_data[, samples, drop = FALSE]
  mirna_subset <- mirna_data[, samples, drop = FALSE]
  
  # Calculate correlations only for predicted interactions
  cat("  Calculating", nrow(interactions_df), "correlations...\n")
  
  correlations <- interactions_df %>%
    rowwise() %>%
    mutate(
      # Calculate correlation
      cor_value = cor(mrna_subset[mRNA, ], 
                     mirna_subset[miRNA, ], 
                     method = "spearman"),
      # Calculate p-value
      p_value = tryCatch({
        cor.test(mrna_subset[mRNA, ], 
                mirna_subset[miRNA, ], 
                method = "spearman")$p.value
      }, error = function(e) NA_real_),
      
      # NEW: Calculate mean expression values for this condition
      mean_expr_mRNA = mean(mrna_subset[mRNA, ], na.rm = TRUE),
      mean_expr_miRNA = mean(mirna_subset[miRNA, ], na.rm = TRUE),
      
      # OPTIONAL: Also calculate SD or other statistics
      sd_expr_mRNA = sd(mrna_subset[mRNA, ], na.rm = TRUE),
      sd_expr_miRNA = sd(mirna_subset[miRNA, ], na.rm = TRUE),
      
      # Add metadata
      timepoint = timepoint_val,
      treatment = treatment_val,
      n_samples = n_samples
    ) %>%
    ungroup() %>%
    filter(!is.na(cor_value), !is.na(p_value))
  
  cat("  Done! Valid correlations:", nrow(correlations), "\n\n")
  
  return(correlations)
}

# Calculate correlations for all conditions 
all_correlations <- bind_rows(
  calculate_condition_correlations(
    mrna_norm, mirna_norm, 
    miranda_data_filtered, metadata,  
    "TP0", "Acclimation"),
  calculate_condition_correlations(
    mrna_norm, mirna_norm, 
    miranda_data_filtered, metadata,
    "TP5", "Ambient"),
  calculate_condition_correlations(
    mrna_norm, mirna_norm, 
    miranda_data_filtered, metadata,
    "TP5", "Heat"),
  calculate_condition_correlations(
    mrna_norm, mirna_norm, 
    miranda_data_filtered, metadata,
    "TP7", "Ambient"),
  calculate_condition_correlations(
    mrna_norm, mirna_norm, 
    miranda_data_filtered, metadata,
    "TP7", "Heat"))
length(unique(all_correlations$miRNA))
length(unique(all_correlations$mRNA))
```

Apply multiple testing correction for pvalues 
```{r}
all_correlations <- all_correlations %>%
  mutate(
    p_adj = p.adjust(p_value, method = "BH"),
    pair_id = paste(miRNA, mRNA, sep = "_"))

cat("Total correlation tests:", nrow(all_correlations), "\n")
cat("Significant at FDR < 0.05:", sum(all_correlations$p_adj < 0.05), "\n")
cat("Significant at FDR < 0.01:", sum(all_correlations$p_adj < 0.01), "\n\n")
```

Save correlation df
```{r}
write.csv(all_correlations, "../output/Molecular/interactions/networks/all_spearman_correlations_by_conditions.csv")
```

## Filter correlation data

Filter so that miRNA expression is greater than mRNA expression (to stay in line with canonical mechanism of miRNA repression)
```{r}
all_correlations_high_miRNA <- all_correlations %>%
  filter(mean_expr_miRNA > mean_expr_mRNA)
length(unique(all_correlations_high_miRNA$miRNA))
length(unique(all_correlations_high_miRNA$mRNA))
```

## Calculate bipartite network metrics 

Calculate the following network metrics for each condition (TP0, TP5 ambient, TP5 heat, TP7 ambient, TP7 heat):
- Degree - number of target mRNAs per miRNA
- Betweenness - fewest number of targets to connect to another miRNA. High betweenness = connector miRNA, connected to other miRNA networks; low betweenness = less connected to other miRNA networks, more peripheral. Range from 0 to infinite. 
- Degree of specialization (d') - the selectivity of miRNA with their targets. Ranges from 0 to 1, with 1 being a perfect specialist (ie miRNA and its targets are completely disconnected from other miRNAs and their targets).

These metrics were derived from [Despard et al. 2025](https://onlinelibrary.wiley.com/doi/10.1002/ece3.71351).

The following chunk are custom scripts for bipartite network calculations. I tried using the bipartite r package but was running into issues with run time. 
```{r custom functions for network calculations}
# Degree for "higher" level (rows): number of non-zero links per miRNA
miRNA_degree <- function(bp_matrix) {
  rowSums(bp_matrix > 0)
}

# Simple betweenness centrality on miRNA projection:
# 1) project bipartite matrix onto miRNAs: B = A %*% t(A)
# 2) compute betweenness on unweighted graph defined by B > 0
miRNA_betweenness <- function(bp_matrix) {
  A <- (bp_matrix > 0) * 1
  if (nrow(A) < 3) {
    return(setNames(rep(0, nrow(A)), rownames(A)))
  }
  B <- A %*% t(A)      # miRNA–miRNA projection (weighted)
  G <- (B > 0) * 1     # unweighted adjacency

  n <- nrow(G)
  bt <- numeric(n)
  names(bt) <- rownames(G)

  # Brandes-like betweenness for unweighted graphs
  for (s in seq_len(n)) {
    S <- integer(0)
    P <- vector("list", n)
    sigma <- rep(0, n); sigma[s] <- 1
    d <- rep(-1L, n); d[s] <- 0L

    Q <- c(s)
    while (length(Q) > 0) {
      v <- Q[1]; Q <- Q[-1]
      S <- c(S, v)
      nbrs <- which(G[v, ] != 0)
      for (w in nbrs) {
        if (d[w] < 0L) {
          d[w] <- d[v] + 1L
          Q <- c(Q, w)
        }
        if (d[w] == d[v] + 1L) {
          sigma[w] <- sigma[w] + sigma[v]
          P[[w]] <- c(P[[w]], v)
        }
      }
    }

    delta <- rep(0, n)
    while (length(S) > 0) {
      w <- S[length(S)]
      S <- S[-length(S)]
      for (v in P[[w]]) {
        if (sigma[w] > 0) {
          delta[v] <- delta[v] + (sigma[v] / sigma[w]) * (1 + delta[w])
        }
      }
      if (w != s) {
        bt[w] <- bt[w] + delta[w]
      }
    }
  }

  bt
}

# Blüthgen's d' specialization for miRNAs (rows).
# Treats entries >0 as interactions; uses information-theoretic formula.
miRNA_dprime <- function(bp_matrix) {
  A <- as.matrix(bp_matrix)
  A[A < 0] <- 0

  row_tot <- rowSums(A)
  col_tot <- colSums(A)
  Ttot <- sum(A)

  if (Ttot == 0 || all(row_tot == 0) || all(col_tot == 0)) {
    return(setNames(rep(NA_real_, nrow(A)), rownames(A)))
  }

  # p_ij: interaction probability per row
  p_ij <- sweep(A, 1, row_tot, FUN = "/")
  p_j  <- col_tot / Ttot

  dprime <- numeric(nrow(A))
  names(dprime) <- rownames(A)

  for (i in seq_len(nrow(A))) {
    if (row_tot[i] == 0) {
      dprime[i] <- NA_real_
      next
    }
    p_i <- p_ij[i, ]
    used <- p_i > 0 & p_j > 0
    if (!any(used)) {
      dprime[i] <- NA_real_
      next
    }

    # Kullback–Leibler divergence K_i
    Ki <- sum(p_i[used] * log(p_i[used] / p_j[used]))

    # approximate K_max for given p_j: perfect specialization
    # if all p_j[used] equal, Kmax can become 0 or NA, guard explicitly
    jstar <- which.min(p_j[used])
    p_star <- numeric(sum(used))
    p_star[jstar] <- 1

    # suppress warnings in case of 0*log(0/0)
    Kmax_vec <- suppressWarnings(p_star * log(p_star / p_j[used]))
    Kmax <- sum(Kmax_vec[is.finite(Kmax_vec)])

    if (is.na(Kmax) || Kmax <= 0) {
      dprime[i] <- NA_real_
    } else {
      dprime[i] <- Ki / Kmax
    }
  }

  dprime
}

create_bipartite_matrix_despard <- function(
  cor_data,
  timepoint_val,
  treatment_val,
  cor_threshold = 0.1
) {
  # Filter for this condition with strong correlations
  filtered_data <- cor_data %>%
    filter(
      timepoint == timepoint_val,
      treatment == treatment_val,
      !is.na(cor_value),
      abs(cor_value) >= cor_threshold
    ) %>%
    select(miRNA, mRNA) %>%
    distinct() %>%
    mutate(presence = 1) # Unweighted (presence/absence)

  if (nrow(filtered_data) == 0) {
    return(matrix(
      nrow = 0, ncol = 0,
      dimnames = list(character(0), character(0))
    ))
  }

  # Create matrix: rows = miRNAs (higher level), cols = mRNAs (lower level)
  bp_matrix <- filtered_data %>%
    pivot_wider(
      names_from  = mRNA,
      values_from = presence,
      values_fill = 0
    ) %>%
    column_to_rownames("miRNA") %>%
    as.matrix()

  bp_matrix
}
```

Create bipartite matrics for all conditions
```{r}
bp_TP0 <- create_bipartite_matrix_despard(
  all_correlations_high_miRNA,
  "TP0", "Acclimation",
  cor_threshold = 0.0)

bp_TP5_Ambient <- create_bipartite_matrix_despard(
  all_correlations_high_miRNA,
  "TP5", "Ambient",
  cor_threshold = 0.0)

bp_TP5_Heat <- create_bipartite_matrix_despard(
  all_correlations_high_miRNA,
  "TP5", "Heat",
  cor_threshold = 0.0)

bp_TP7_Ambient <- create_bipartite_matrix_despard(
  all_correlations_high_miRNA,
  "TP7", "Ambient",
  cor_threshold = 0.0)

bp_TP7_Heat <- create_bipartite_matrix_despard(
  all_correlations_high_miRNA,
  "TP7", "Heat",
  cor_threshold = 0.0)

bp_matrices_list <- list(
  "TP0_Acclimation" = bp_TP0,
  "TP5_Ambient"     = bp_TP5_Ambient,
  "TP5_Heat"        = bp_TP5_Heat,
  "TP7_Ambient"     = bp_TP7_Ambient,
  "TP7_Heat"        = bp_TP7_Heat)

# Check dimensions
for (name in names(bp_matrices_list)) {
  cat(
    name, ":",
    nrow(bp_matrices_list[[name]]), "miRNAs x",
    ncol(bp_matrices_list[[name]]), "mRNAs,",
    sum(bp_matrices_list[[name]]), "interactions\n")}
```

Calculate network metrics (degree, betweenness, d') for each condition
```{r}
# TP0 Acclimation
deg_TP0 <- miRNA_degree(bp_TP0)
bt_TP0  <- miRNA_betweenness(bp_TP0)
dpr_TP0 <- miRNA_dprime(bp_TP0)

df_TP0 <- data.frame(
  condition   = "TP0_Acclimation",
  miRNA       = names(deg_TP0),
  degree      = as.numeric(deg_TP0),
  betweenness = as.numeric(bt_TP0[names(deg_TP0)]),
  dprime      = as.numeric(dpr_TP0[names(deg_TP0)]),
  row.names   = NULL)

# TP5 Ambient
deg_TP5_amb <- miRNA_degree(bp_TP5_Ambient)
bt_TP5_amb  <- miRNA_betweenness(bp_TP5_Ambient)
dpr_TP5_amb <- miRNA_dprime(bp_TP5_Ambient)

df_TP5_amb <- data.frame(
  condition   = "TP5_Ambient",
  miRNA       = names(deg_TP5_amb),
  degree      = as.numeric(deg_TP5_amb),
  betweenness = as.numeric(bt_TP5_amb[names(deg_TP5_amb)]),
  dprime      = as.numeric(dpr_TP5_amb[names(deg_TP5_amb)]),
  row.names   = NULL)

# TP5 Heat
deg_TP5_heat <- miRNA_degree(bp_TP5_Heat)
bt_TP5_heat  <- miRNA_betweenness(bp_TP5_Heat)
dpr_TP5_heat <- miRNA_dprime(bp_TP5_Heat)

df_TP5_heat <- data.frame(
  condition   = "TP5_Heat",
  miRNA       = names(deg_TP5_heat),
  degree      = as.numeric(deg_TP5_heat),
  betweenness = as.numeric(bt_TP5_heat[names(deg_TP5_heat)]),
  dprime      = as.numeric(dpr_TP5_heat[names(deg_TP5_heat)]),
  row.names   = NULL)

# TP7 Ambient
deg_TP7_amb <- miRNA_degree(bp_TP7_Ambient)
bt_TP7_amb  <- miRNA_betweenness(bp_TP7_Ambient)
dpr_TP7_amb <- miRNA_dprime(bp_TP7_Ambient)

df_TP7_amb <- data.frame(
  condition   = "TP7_Ambient",
  miRNA       = names(deg_TP7_amb),
  degree      = as.numeric(deg_TP7_amb),
  betweenness = as.numeric(bt_TP7_amb[names(deg_TP7_amb)]),
  dprime      = as.numeric(dpr_TP7_amb[names(deg_TP7_amb)]),
  row.names   = NULL)

# TP7 Heat
deg_TP7_heat <- miRNA_degree(bp_TP7_Heat)
bt_TP7_heat  <- miRNA_betweenness(bp_TP7_Heat)
dpr_TP7_heat <- miRNA_dprime(bp_TP7_Heat)

df_TP7_heat <- data.frame(
  condition   = "TP7_Heat",
  miRNA       = names(deg_TP7_heat),
  degree      = as.numeric(deg_TP7_heat),
  betweenness = as.numeric(bt_TP7_heat[names(deg_TP7_heat)]),
  dprime      = as.numeric(dpr_TP7_heat[names(deg_TP7_heat)]),
  row.names   = NULL)

network_metrics <- rbind(df_TP0, df_TP5_amb, df_TP7_amb, df_TP5_heat, df_TP7_heat)

# Save as csv 
write.csv(network_metrics, "../output/Molecular/interactions/networks/network_metrics.csv")
```

## Seasonal network metrics 

Subset network metrics by season
```{r}
seasonal_network_metrics <- network_metrics %>%
  filter(condition %in% c("TP0_Acclimation", "TP5_Ambient", "TP7_Ambient"))
```

Make PCA of seasonal network metrics 
```{r}
# Make PCA 
metrics <- seasonal_network_metrics[, c("degree", "betweenness", "dprime")]
pca <- prcomp(metrics, center = TRUE, scale. = TRUE)

# Extract scores 
scores <- as.data.frame(pca$x)
scores$condition <- seasonal_network_metrics$condition
scores$miRNA <- seasonal_network_metrics$miRNA

# Calculate variance explained
var_explained <- pca$sdev^2 / sum(pca$sdev^2)
pc1_lab <- paste0("PC1 (", round(var_explained[1] * 100, 1), "%)")
pc2_lab <- paste0("PC2 (", round(var_explained[2] * 100, 1), "%)")

# Plot
ggplot(scores, aes(PC1, PC2, color = condition)) +
  geom_point(size = 2, alpha = 0.8) +
  scale_color_brewer(palette = "Set1") +
  labs(x = pc1_lab, y = pc2_lab, color = "Condition") +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_line(color = "grey90"),
    legend.position = "right")
```

Hover labels to identify miRNAs 
```{r}
plt <- ggplot(scores, aes(PC1, PC2, color = condition,
                          text = paste0("miRNA: ", miRNA))) +
  geom_point(size = 2, alpha = 0.8) +
  labs(x = pc1_lab, y = pc2_lab, color = "Condition") +
  theme_minimal(base_size = 14)

ggplotly(plt, tooltip = c("text", "x", "y"))

```

Remake the figures above ^^ to be pretty! Maybe label some of the 'hub' miRNAs'

Make violin plots for seasonal network metrics 
```{r}
# Ensure condition is ordered chronologically
seasonal_network_metrics <- seasonal_network_metrics %>%
  mutate(condition = factor(condition, 
                           levels = c("TP0_Acclimation", "TP5_Ambient", "TP7_Ambient")))

# Degree plot 
degree_seasonal_violin <- ggplot(seasonal_network_metrics, aes(x = condition, y = degree, fill = condition)) +
  geom_violin(alpha = 0.7, trim = FALSE) +
  geom_boxplot(width = 0.15, fill = "white", outlier.alpha = 0) +
  scale_fill_manual(values = c("TP0_Acclimation" = "#E69F00", 
                              "TP5_Ambient" = "#56B4E9", 
                              "TP7_Ambient" = "#009E73")) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Condition", 
       y = "Degree (number of mRNA targets)",
       title = "miRNA degree distribution across seasonal timepoints"); degree_seasonal_violin

# Betweenness plot 
betweenness_seasonal_violin <- ggplot(seasonal_network_metrics, aes(x = condition, y = betweenness, fill = condition)) +
  geom_violin(alpha = 0.7, trim = FALSE) +
  geom_boxplot(width = 0.15, fill = "white", outlier.alpha = 0) +
  scale_fill_manual(values = c("TP0_Acclimation" = "#E69F00", 
                              "TP5_Ambient" = "#56B4E9", 
                              "TP7_Ambient" = "#009E73")) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Condition", 
       y = "Betweenness",
       title = "miRNA betweenness distribution across seasonal timepoints"); betweenness_seasonal_violin

# dprime plot 
dprime_seasonal_violin <- ggplot(seasonal_network_metrics, aes(x = condition, y = dprime, fill = condition)) +
  geom_violin(alpha = 0.7, trim = FALSE) +
  geom_boxplot(width = 0.15, fill = "white", outlier.alpha = 0) +
  scale_fill_manual(values = c("TP0_Acclimation" = "#E69F00", 
                              "TP5_Ambient" = "#56B4E9", 
                              "TP7_Ambient" = "#009E73")) +
  theme_linedraw(base_size = 12) +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Condition", 
       y = "d'",
       title = "miRNA d' distribution across seasonal timepoints"); dprime_seasonal_violin
```

Test for differences in degree, betweenness and dprime by season
```{r}
# KRUSKAL-WALLIS TESTS (non-parametric)
kruskal_results <- seasonal_network_metrics %>%
  summarise(
    degree_kw = list(kruskal.test(degree ~ season)),
    betweenness_kw = list(kruskal.test(betweenness ~ season)),
    dprime_kw = list(kruskal.test(dprime ~ season))
  ) %>%
  mutate(
    degree_p = map_dbl(degree_kw, ~.x$p.value),
    betweenness_p = map_dbl(betweenness_kw, ~.x$p.value),
    dprime_p = map_dbl(dprime_kw, ~.x$p.value)
  ) %>%
  select(ends_with("_p"))
print(kruskal_results)
```

No significant differences across season for all metrics. 

## Seasonal correlation trajectories 

Filter correlation data for seasonal 
```{r}
seasonal_all_correlations_high_miRNA <- all_correlations_high_miRNA %>%
  filter(timepoint %in% c("TP0", "TP5", "TP7")) %>%
  filter(treatment %in% c("Acclimation", "Ambient"))
```

Reshape df for trajectory calculations
```{r}
pair_trajectories <- seasonal_all_correlations_high_miRNA %>%
  select(pair_id, miRNA, mRNA, timepoint, cor_value) %>%
  #mutate(time_num = recode(timepoint, "TP0" = 0, "TP5" = 5, "TP7" = 7)) %>%
  group_by(pair_id, miRNA, mRNA, timepoint) %>%
  summarise(cor_value = mean(cor_value, na.rm = TRUE), .groups = "drop") %>%
  # Drop time_num here, keep only what's needed for pivot
  #select(-time_num) %>%
  pivot_wider(names_from = timepoint, values_from = cor_value, 
              values_fill = NA, values_fn = mean) %>%
  # Add back complete trajectory filter
  filter(!is.na(TP0), !is.na(TP5), !is.na(TP7))
```

Fit trajectories
```{r}
fit_pair_trajectory <- function(row) {
  df <- data.frame(time = c(0, 5, 7), cor = c(row$TP0, row$TP5, row$TP7))
  mod <- lm(cor ~ poly(time, 2), data = df)
  
  tidy(mod) %>%        # Now broom::tidy() will work
    filter(term != "(Intercept)") %>%
    mutate(
      pair_id = row$pair_id,
      miRNA = row$miRNA, 
      mRNA = row$mRNA
    ) %>%
    select(pair_id, miRNA, mRNA, term, estimate) %>%
    pivot_wider(names_from = term, values_from = estimate)
}

pair_fits <- pair_trajectories %>%
  rowwise() %>%
  do(fit_pair_trajectory(.)) %>%
  ungroup()
```

Cluster trajectories 
```{r}
# Extract clustering features
features <- pair_fits %>%
  rename(linear = `poly(time, 2)1`, quadratic = `poly(time, 2)2`) %>%
  select(pair_id, linear, quadratic)

# Standardize features
features_scaled <- scale(features[, c("linear", "quadratic")])

# K-means clustering (try k=4-6)
set.seed(123)
k <- 5
clusters <- kmeans(features_scaled, centers = k, nstart = 100)

features$cluster <- as.factor(clusters$cluster)

# Join with pair trajectories df 
pair_trajectories <- pair_trajectories %>%
  left_join(features %>% select(pair_id, cluster), by = "pair_id")
```

Plot trajectories 
```{r}
# Prepare long format data (same as before)
trajectory_long <- pair_trajectories %>%
  left_join(features %>% select(pair_id), by = "pair_id") %>%
  pivot_longer(cols = starts_with("TP"), names_to = "timepoint", values_to = "cor") %>%
  mutate(season = recode(timepoint, "TP0" = "Feb", "TP5" = "June", "TP7" = "Aug"))

# Stats for mean ± SE
cluster_stats <- trajectory_long %>%
  group_by(cluster, timepoint) %>%
  summarise(
    mean_cor = mean(cor, na.rm = TRUE),
    se_cor = sd(cor, na.rm = TRUE)/sqrt(n()),
    n_pairs = n(),
    .groups = "drop"
  )

# Single plot with faceted panels
p_faceted <- ggplot() +
  # Faint individual trajectories in each panel
  geom_line(data = trajectory_long, 
            aes(x = timepoint, y = cor, group = pair_id), 
            alpha = 0.08, color = "grey60", linewidth = 0.4) +
  # Mean ± SE per cluster (red lines)
  geom_line(data = cluster_stats, 
            aes(x = timepoint, y = mean_cor, group = cluster), 
            color = "red3", linewidth = 1.3) +
  geom_ribbon(data = cluster_stats, 
              aes(x = timepoint, ymin = mean_cor - se_cor, 
                  ymax = mean_cor + se_cor), 
              fill = "red", alpha = 0.2, color = NA) +
  geom_point(data = cluster_stats, 
             aes(x = timepoint, y = mean_cor), 
             color = "red3", size = 2.8) +
  
  # Facet by cluster (separate panels)
  facet_wrap(~ cluster, scales = "free_y", ncol = 5) +
  
  #scale_x_continuous(breaks = c(0, 5, 7), labels = c("Feb", "June", "Aug")) +
  labs(x = "Season", y = "Spearman correlation",
       title = "Seasonal miRNA-mRNA pair correlation trajectories by cluster") +
  theme_bw(base_size = 12) +
  theme(
    strip.text = element_text(face = "bold", size = 11),
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  ); p_faceted
```

## Enrichment of clusters -- seasonal 

Before analysis, make gene2go file from annotation information
```{r}
# Read in annotation info
annot <- read.delim("/Users/jillashey/Desktop/PutnamLab/Astrangia_Genome/Apoculata_v2.0_GeneAnnotation_combined_prelim.txt", header = T)
annot$Protein_ID <- gsub("model", "TU", annot$Protein_ID)
annot$GO <- paste(annot$GO_Swiss.Prot, annot$GO_Trembl, sep = ";")

# Select gene name and GO columns only 
go_ast <- annot %>%
  dplyr::select(Protein_ID, GO) %>%
  mutate(GO = case_when(
    grepl("^NA$|^NA;|;$|^;$", GO, ignore.case = TRUE) ~ NA_character_,
    TRUE ~ GO
  ))

# Rename cols
colnames(go_ast) <- c("mRNA", "GO")

# Save as tsv
write_tsv(go_ast, file = "../data/Molecular/Ast_gene2go.tab")
```

Read in gene2go information (generated above)
```{r}
go_ast <- read.delim("../data/Molecular/Ast_gene2go.tab", sep = "\t")
```

Read in gene-to-go-mappings
```{r}
gene2go_topgo <- readMappings("../data/Molecular/Ast_gene2go.tab", IDsep=";")
```

Set function to select genes of interest (ie those that have pvalue < 0.05)
```{r}
topDiffGenes <- function(allScore) {
return(allScore < 0.05)}
```

### Cluster 1 seasonal

Subset by Cluster 1 and select only negative correlations for TP0 and TP7 
```{r}
subset_cluster1 <- pair_trajectories %>%
  filter(cluster == 1, TP0 < 0, TP5 > 0, TP7 < 0)
```

Make list of genes for input to topGO
```{r}
# Genes of interest 
clust_genes <- as.character(unique(subset_cluster1$mRNA))

# All genes 
all_genes <- as.character(go_ast$mRNA)

# Apply 1 or 0 if gene is gene of interest 
GeneList <- factor(as.integer(all_genes %in% clust_genes))
names(GeneList) <- all_genes
``` 

#### Biological Processes - cluster 1 seasonal

Create `topGOdata` object, which is required for topGO analysis
```{r, include=F}
GO_BP <-new("topGOdata", ontology="BP", gene2GO=gene2go_topgo, allGenes=GeneList, annot = annFUN.gene2GO, geneSel=topDiffGenes)
```

Run GO enrichment test 
```{r, include=F}
GO_BP_FE <- runTest(GO_BP, algorithm="weight01", statistic="fisher")
```

Generate results table 
```{r}
GO_BP_En <- GenTable(GO_BP, Fisher = GO_BP_FE, orderBy = "Fisher", numChar = 51, topNodes = 100)
```

Filter by significant results
```{r}
GO_BP_En$Fisher<-as.numeric(GO_BP_En$Fisher)
GO_BP_En_sig<-GO_BP_En[GO_BP_En$Fisher<0.05,]
GO_BP_En_sig$ontology <- "Biological Processes"
GO_BP_En_sig$cluster <- "1"
```

#### Molecular Functions - cluster 1 seasonal

Create `topGOdata` object, which is required for topGO analysis
```{r, include=F}
GO_MF <-new("topGOdata", ontology="MF", gene2GO=gene2go_topgo, allGenes=GeneList, annot = annFUN.gene2GO, geneSel=topDiffGenes)
```

Run GO enrichment test 
```{r, include=F}
GO_MF_FE <- runTest(GO_MF, algorithm="weight01", statistic="fisher")
```

Generate results table 
```{r}
GO_MF_En <- GenTable(GO_MF, Fisher = GO_MF_FE, orderBy = "Fisher", numChar = 51, topNodes = 100)
```

Filter by significant results
```{r}
GO_MF_En$Fisher<-as.numeric(GO_MF_En$Fisher)
GO_MF_En_sig<-GO_MF_En[GO_MF_En$Fisher<0.05,]
GO_MF_En_sig$ontology <- "Molecular Functions"
GO_MF_En_sig$cluster <- "1"
```

#### Bind functional results for cluster 1 and save as csv

```{r}
cluster1_seasonal_functional <- rbind(GO_BP_En_sig, GO_MF_En_sig)

# Save as csv 
write.csv(cluster1_seasonal_functional, "../output/Molecular/interactions/networks/seasonal_cluster1_functional.csv")
```

### Cluster 2 seasonal

Subset by Cluster 2 and select only negative correlations for TP0 
```{r}
subset_cluster2 <- pair_trajectories %>%
  filter(cluster == 2, TP0 < 0)
```

Make list of genes for input to topGO
```{r}
# Genes of interest 
clust_genes <- as.character(unique(subset_cluster2$mRNA))

# All genes 
all_genes <- as.character(go_ast$mRNA)

# Apply 1 or 0 if gene is gene of interest 
GeneList <- factor(as.integer(all_genes %in% clust_genes))
names(GeneList) <- all_genes
``` 

#### Biological Processes - cluster 2 seasonal

Create `topGOdata` object, which is required for topGO analysis
```{r, include=F}
GO_BP <-new("topGOdata", ontology="BP", gene2GO=gene2go_topgo, allGenes=GeneList, annot = annFUN.gene2GO, geneSel=topDiffGenes)
```

Run GO enrichment test 
```{r, include=F}
GO_BP_FE <- runTest(GO_BP, algorithm="weight01", statistic="fisher")
```

Generate results table 
```{r}
GO_BP_En <- GenTable(GO_BP, Fisher = GO_BP_FE, orderBy = "Fisher", numChar = 51, topNodes = 100)
```

Filter by significant results
```{r}
GO_BP_En$Fisher<-as.numeric(GO_BP_En$Fisher)
GO_BP_En_sig<-GO_BP_En[GO_BP_En$Fisher<0.05,]
GO_BP_En_sig$ontology <- "Biological Processes"
GO_BP_En_sig$cluster <- "2"
```

#### Molecular Functions - cluster 2 seasonal

Create `topGOdata` object, which is required for topGO analysis
```{r, include=F}
GO_MF <-new("topGOdata", ontology="MF", gene2GO=gene2go_topgo, allGenes=GeneList, annot = annFUN.gene2GO, geneSel=topDiffGenes)
```

Run GO enrichment test 
```{r, include=F}
GO_MF_FE <- runTest(GO_MF, algorithm="weight01", statistic="fisher")
```

Generate results table 
```{r}
GO_MF_En <- GenTable(GO_MF, Fisher = GO_MF_FE, orderBy = "Fisher", numChar = 51, topNodes = 100)
```

Filter by significant results
```{r}
GO_MF_En$Fisher<-as.numeric(GO_MF_En$Fisher)
GO_MF_En_sig<-GO_MF_En[GO_MF_En$Fisher<0.05,]
GO_MF_En_sig$ontology <- "Molecular Functions"
GO_MF_En_sig$cluster <- "2"
```

#### Bind functional results for cluster 2 and save as csv

```{r}
cluster2_seasonal_functional <- rbind(GO_BP_En_sig, GO_MF_En_sig)

# Save as csv 
write.csv(cluster2_seasonal_functional, "../output/Molecular/interactions/networks/seasonal_cluster2_functional.csv")
```

### Cluster 3 seasonal

Subset by Cluster 3 and select only negative correlations for TP7
```{r}
subset_cluster3 <- pair_trajectories %>%
  filter(cluster == 3, TP7 < 0)
```

Make list of genes for input to topGO
```{r}
# Genes of interest 
clust_genes <- as.character(unique(subset_cluster3$mRNA))

# All genes 
all_genes <- as.character(go_ast$mRNA)

# Apply 1 or 0 if gene is gene of interest 
GeneList <- factor(as.integer(all_genes %in% clust_genes))
names(GeneList) <- all_genes
``` 

#### Biological Processes - cluster 3 seasonal

Create `topGOdata` object, which is required for topGO analysis
```{r, include=F}
GO_BP <-new("topGOdata", ontology="BP", gene2GO=gene2go_topgo, allGenes=GeneList, annot = annFUN.gene2GO, geneSel=topDiffGenes)
```

Run GO enrichment test 
```{r, include=F}
GO_BP_FE <- runTest(GO_BP, algorithm="weight01", statistic="fisher")
```

Generate results table 
```{r}
GO_BP_En <- GenTable(GO_BP, Fisher = GO_BP_FE, orderBy = "Fisher", numChar = 51, topNodes = 100)
```

Filter by significant results
```{r}
GO_BP_En$Fisher<-as.numeric(GO_BP_En$Fisher)
GO_BP_En_sig<-GO_BP_En[GO_BP_En$Fisher<0.05,]
GO_BP_En_sig$ontology <- "Biological Processes"
GO_BP_En_sig$cluster <- "3"
```

#### Molecular Functions - cluster 3 seasonal

Create `topGOdata` object, which is required for topGO analysis
```{r, include=F}
GO_MF <-new("topGOdata", ontology="MF", gene2GO=gene2go_topgo, allGenes=GeneList, annot = annFUN.gene2GO, geneSel=topDiffGenes)
```

Run GO enrichment test 
```{r, include=F}
GO_MF_FE <- runTest(GO_MF, algorithm="weight01", statistic="fisher")
```

Generate results table 
```{r}
GO_MF_En <- GenTable(GO_MF, Fisher = GO_MF_FE, orderBy = "Fisher", numChar = 51, topNodes = 100)
```

Filter by significant results
```{r}
GO_MF_En$Fisher<-as.numeric(GO_MF_En$Fisher)
GO_MF_En_sig<-GO_MF_En[GO_MF_En$Fisher<0.05,]
GO_MF_En_sig$ontology <- "Molecular Functions"
GO_MF_En_sig$cluster <- "3"
```

#### Bind functional results for cluster 3 and save as csv

```{r}
cluster3_seasonal_functional <- rbind(GO_BP_En_sig, GO_MF_En_sig)

# Save as csv 
write.csv(cluster3_seasonal_functional, "../output/Molecular/interactions/networks/seasonal_cluster3_functional.csv")
```

### Cluster 4 seasonal

Subset by Cluster 4 and select only negative correlations for TP5, positive correlations for TP0 and TP7
```{r}
subset_cluster4 <- pair_trajectories %>%
  filter(cluster == 4, TP0 > 0, TP5 < 0, TP7 > 0)
```

Make list of genes for input to topGO
```{r}
# Genes of interest 
clust_genes <- as.character(unique(subset_cluster4$mRNA))

# All genes 
all_genes <- as.character(go_ast$mRNA)

# Apply 1 or 0 if gene is gene of interest 
GeneList <- factor(as.integer(all_genes %in% clust_genes))
names(GeneList) <- all_genes
``` 

#### Biological Processes - cluster 4 seasonal

Create `topGOdata` object, which is required for topGO analysis
```{r, include=F}
GO_BP <-new("topGOdata", ontology="BP", gene2GO=gene2go_topgo, allGenes=GeneList, annot = annFUN.gene2GO, geneSel=topDiffGenes)
```

Run GO enrichment test 
```{r, include=F}
GO_BP_FE <- runTest(GO_BP, algorithm="weight01", statistic="fisher")
```

Generate results table 
```{r}
GO_BP_En <- GenTable(GO_BP, Fisher = GO_BP_FE, orderBy = "Fisher", numChar = 51, topNodes = 100)
```

Filter by significant results
```{r}
GO_BP_En$Fisher<-as.numeric(GO_BP_En$Fisher)
GO_BP_En_sig<-GO_BP_En[GO_BP_En$Fisher<0.05,]
GO_BP_En_sig$ontology <- "Biological Processes"
GO_BP_En_sig$cluster <- "4"
```

#### Molecular Functions - cluster 4 seasonal

Create `topGOdata` object, which is required for topGO analysis
```{r, include=F}
GO_MF <-new("topGOdata", ontology="MF", gene2GO=gene2go_topgo, allGenes=GeneList, annot = annFUN.gene2GO, geneSel=topDiffGenes)
```

Run GO enrichment test 
```{r, include=F}
GO_MF_FE <- runTest(GO_MF, algorithm="weight01", statistic="fisher")
```

Generate results table 
```{r}
GO_MF_En <- GenTable(GO_MF, Fisher = GO_MF_FE, orderBy = "Fisher", numChar = 51, topNodes = 100)
```

Filter by significant results
```{r}
GO_MF_En$Fisher<-as.numeric(GO_MF_En$Fisher)
GO_MF_En_sig<-GO_MF_En[GO_MF_En$Fisher<0.05,]
GO_MF_En_sig$ontology <- "Molecular Functions"
GO_MF_En_sig$cluster <- "4"
```

#### Bind functional results for cluster 4 and save as csv

```{r}
cluster4_seasonal_functional <- rbind(GO_BP_En_sig, GO_MF_En_sig)

# Save as csv 
write.csv(cluster4_seasonal_functional, "../output/Molecular/interactions/networks/seasonal_cluster4_functional.csv")
```

### Cluster 5 seasonal

Subset by Cluster 5 and select only negative correlations for all timepoints
```{r}
subset_cluster5 <- pair_trajectories %>%
  filter(cluster == 5, TP0 < 0, TP5 < 0, TP7 < 0)
```

Make list of genes for input to topGO
```{r}
# Genes of interest 
clust_genes <- as.character(unique(subset_cluster5$mRNA))

# All genes 
all_genes <- as.character(go_ast$mRNA)

# Apply 1 or 0 if gene is gene of interest 
GeneList <- factor(as.integer(all_genes %in% clust_genes))
names(GeneList) <- all_genes
``` 

#### Biological Processes - cluster 5 seasonal

Create `topGOdata` object, which is required for topGO analysis
```{r, include=F}
GO_BP <-new("topGOdata", ontology="BP", gene2GO=gene2go_topgo, allGenes=GeneList, annot = annFUN.gene2GO, geneSel=topDiffGenes)
```

Run GO enrichment test 
```{r, include=F}
GO_BP_FE <- runTest(GO_BP, algorithm="weight01", statistic="fisher")
```

Generate results table 
```{r}
GO_BP_En <- GenTable(GO_BP, Fisher = GO_BP_FE, orderBy = "Fisher", numChar = 51, topNodes = 100)
```

Filter by significant results
```{r}
GO_BP_En$Fisher<-as.numeric(GO_BP_En$Fisher)
GO_BP_En_sig<-GO_BP_En[GO_BP_En$Fisher<0.05,]
GO_BP_En_sig$ontology <- "Biological Processes"
GO_BP_En_sig$cluster <- "5"
```

#### Molecular Functions - cluster 5 seasonal

Create `topGOdata` object, which is required for topGO analysis
```{r, include=F}
GO_MF <-new("topGOdata", ontology="MF", gene2GO=gene2go_topgo, allGenes=GeneList, annot = annFUN.gene2GO, geneSel=topDiffGenes)
```

Run GO enrichment test 
```{r, include=F}
GO_MF_FE <- runTest(GO_MF, algorithm="weight01", statistic="fisher")
```

Generate results table 
```{r}
GO_MF_En <- GenTable(GO_MF, Fisher = GO_MF_FE, orderBy = "Fisher", numChar = 51, topNodes = 100)
```

Filter by significant results
```{r}
GO_MF_En$Fisher<-as.numeric(GO_MF_En$Fisher)
GO_MF_En_sig<-GO_MF_En[GO_MF_En$Fisher<0.05,]
GO_MF_En_sig$ontology <- "Molecular Functions"
GO_MF_En_sig$cluster <- "5"
```

#### Bind functional results for cluster 5 and save as csv

```{r}
cluster5_seasonal_functional <- rbind(GO_BP_En_sig, GO_MF_En_sig)

# Save as csv 
write.csv(cluster5_seasonal_functional, "../output/Molecular/interactions/networks/seasonal_cluster5_functional.csv")
```

## Plot seasonal functional results 

Bind functional results from all clusters 
```{r}
seasonal_functions <- rbind(cluster1_seasonal_functional, cluster2_seasonal_functional, cluster3_seasonal_functional, cluster4_seasonal_functional, cluster5_seasonal_functional)
```

Plot w/ trajectory plots 
```{r}
# ==========================================
# COMBINED TRAJECTORY + FUNCTION PLOTS
# Two columns: trajectory (left) + GO terms (right)
# Rows = clusters
# ==========================================

library(tidyverse)
library(patchwork)
library(ggtext)
library(tidytext)

# ==========================================
# STEP 1: Prepare trajectory data
# ==========================================

# Individual trajectories
trajectory_long <- pair_trajectories %>%
  left_join(features %>% select(pair_id), by = "pair_id") %>%
  pivot_longer(cols = starts_with("TP"), names_to = "timepoint", values_to = "cor") %>%
  mutate(season = recode(timepoint, "TP0" = "February", "TP5" = "June", "TP7" = "August")) %>%
  mutate(season = factor(season, 
                           levels = c("February", "June", "August")))

# Cluster means and SE
cluster_stats <- trajectory_long %>%
  group_by(cluster, season) %>%
  summarise(
    mean_cor = mean(cor),
    se_cor = sd(cor) / sqrt(n()),
    .groups = "drop"
  )

# ==========================================
# STEP 2: Prepare GO enrichment data
# ==========================================

# Get top N GO terms per cluster
top_n_terms <- 10  # Adjust as needed

go_data_plot <- seasonal_functions %>%
  filter(ontology == "Biological Processes") %>%
  group_by(cluster) %>%
  arrange(Fisher) %>%
  slice_head(n = top_n_terms) %>%
  ungroup() %>%
  mutate(
    # Shorten long term names
    Term_short = str_trunc(Term, width = 50, side = "right"),
    # -log10 p-value for plotting
    neglog10p = -log10(Fisher),
    # Order terms by p-value within cluster
    Term_ordered = reorder_within(Term_short, Fisher, cluster)
  )

# ==========================================
# STEP 3: Create trajectory plots for each cluster
# ==========================================

trajectory_plots <- lapply(unique(cluster_stats$cluster), function(clust) {
  
  # Filter data for this cluster
  traj_data <- trajectory_long %>% filter(cluster == clust)
  stat_data <- cluster_stats %>% filter(cluster == clust)
  
  # Create plot
  p <- ggplot() +
    # Horizontal line at zero
    geom_hline(yintercept = 0, linetype = "dotted", color = "black", linewidth = 0.5) +
    
    # Individual trajectories (faint)
    geom_line(data = traj_data, 
              aes(x = season, y = cor, group = pair_id), 
              alpha = 0.08, color = "grey60", linewidth = 0.3) +
    
    # Mean ± SE
    geom_ribbon(data = stat_data, 
                aes(x = season, y = mean_cor,
                    ymin = mean_cor - se_cor, 
                    ymax = mean_cor + se_cor,
                    group = 1), 
                fill = "red3", alpha = 0.2) +
    
    geom_line(data = stat_data, 
              aes(x = season, y = mean_cor, group = 1), 
              color = "red3", linewidth = 1.2) +
    
    geom_point(data = stat_data, 
               aes(x = season, y = mean_cor), 
               color = "red3", size = 3) +
    
    # Labels
    labs(
      title = paste0("Cluster ", clust),
      x = "Season",
      y = "Spearman correlation"
    ) +
    
    theme_bw(base_size = 11) +
    theme(
      plot.title = element_text(face = "bold", size = 12, hjust = 0.5),
      panel.grid.minor = element_blank(),
      axis.text.x = element_text(angle = 0, hjust = 0.5)
    )
  
  return(p)
})

# ==========================================
# STEP 4: Create GO enrichment plots for each cluster
# ==========================================

go_plots <- lapply(unique(go_data_plot$cluster), function(clust) {
  
  # Filter data for this cluster
  go_data <- go_data_plot %>% filter(cluster == clust)
  
  # Create plot
  p <- ggplot(go_data, aes(x = neglog10p, 
                           y = reorder(Term_short, neglog10p),
                           size = Significant)) + 
    geom_point(alpha = 0.8) +                     # Using points instead of bars
    labs(
      x = expression(-log[10](Fisher)),
      y = "",
      size = "Gene Count",
      colour = "Ontology",
      title = paste("Cluster", clust)
    ) +
    
    # Optional: Adjust the range of point sizes to make them readable
    scale_size_continuous(range = c(3, 10)) + 
    
    theme_bw(base_size = 11) +
    theme(
      plot.title = element_text(face = "bold", size = 12, hjust = 0.5),
      axis.text.y = element_text(size = 9),
      panel.grid.minor = element_blank(),
      panel.grid.major.y = element_line(linetype = "dotted", color = "gray80") # Adds a guide line
    )
  
  return(p)
})

# ==========================================
# STEP 5: Combine plots using patchwork
# ==========================================

# Function to combine trajectory + GO for one cluster
combine_cluster_plots <- function(i) {
  trajectory_plots[[i]] + go_plots[[i]] + 
    plot_layout(widths = c(1, 1.2))  # GO plot slightly wider for term names
}

# Combine all clusters vertically
n_clusters <- length(unique(cluster_stats$cluster))

combined_plot <- wrap_plots(
  lapply(1:n_clusters, combine_cluster_plots),
  ncol = 1) #+
#   plot_annotation(
#     title = "Seasonal miRNA-mRNA regulatory dynamics by cluster",
#     theme = theme(
#       plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
#       plot.subtitle = element_text(size = 12, hjust = 0.5)
#     )
#   )

print(combined_plot)

# Save
ggsave("../output/Molecular/interactions/networks/seasonal_cluster_trajectory_functional.pdf", 
       combined_plot, 
       width = 16, height = 4 * n_clusters, 
       limitsize = FALSE)
ggsave("../output/Molecular/interactions/networks/seasonal_cluster_trajectory_functional.png", 
       combined_plot, 
       width = 16, height = 4 * n_clusters, 
       limitsize = FALSE)
```

Add the network plots at the top
```{r}
library(ggplot2)
library(patchwork)
library(dplyr)
library(tidyr)
library(stringr)
library(scales)

# Ensure consistent season factor levels for network metrics
seasonal_network_metrics <- seasonal_network_metrics %>%
  mutate(condition = factor(condition, 
                           levels = c("TP0_Acclimation", "TP5_Ambient", "TP7_Ambient")),
         season = recode(condition, 
                        "TP0_Acclimation" = "February", 
                        "TP5_Ambient" = "June", 
                        "TP7_Ambient" = "August"),
         season = factor(season, levels = c("February", "June", "August")))

# ==========================================
# 1. COMPACT NETWORK VIOLIN PLOTS (TOP ROW A,B,C)
# ==========================================

# Degree violin plot 
degree_violin <- ggplot(seasonal_network_metrics, aes(x = season, y = degree, fill = season)) +
  geom_violin(alpha = 0.7, trim = FALSE, width = 0.8) +
  geom_boxplot(width = 0.12, fill = "white", outlier.alpha = 0) +
  scale_fill_manual(values = c("February" = "#E69F00", "June" = "#56B4E9", "August" = "#009E73")) +
  theme_linedraw(base_size = 14) +
  theme(
    legend.position = "none",
    axis.text.x = element_text(size = 14, angle = 0, hjust = 0.5, colour = "black"),
    axis.text.y = element_text(size = 14, colour = "black"),
    axis.title = element_text(size = 14, colour = "black"),
    plot.title = element_text(size = 16, face = "bold", colour = "black", hjust = 0.5),
    panel.grid.minor = element_blank()
  ) +
  labs(x = "", y = "Degree\n(# mRNA targets)")

# Betweenness violin plot 
betweenness_violin <- ggplot(seasonal_network_metrics, aes(x = season, y = betweenness, fill = season)) +
  geom_violin(alpha = 0.7, trim = FALSE, width = 0.8) +
  geom_boxplot(width = 0.12, fill = "white", outlier.alpha = 0) +
  scale_fill_manual(values = c("February" = "#E69F00", "June" = "#56B4E9", "August" = "#009E73")) +
  scale_y_log10(labels = label_number()) +
  theme_linedraw(base_size = 14) +
  theme(
    legend.position = "none",
    axis.text.x = element_text(size = 14, angle = 0, hjust = 0.5, colour = "black"),
    axis.text.y = element_text(size = 14, colour = "black"),
    axis.title = element_text(size = 14, colour = "black"),
    plot.title = element_text(size = 16, face = "bold", colour = "black", hjust = 0.5),
    panel.grid.minor = element_blank()
  ) +
  labs(x = "", y = "Betweenness\n(log scale)")

# d' violin plot 
dprime_violin <- ggplot(seasonal_network_metrics, aes(x = season, y = dprime, fill = season)) +
  geom_violin(alpha = 0.7, trim = FALSE, width = 0.8) +
  geom_boxplot(width = 0.12, fill = "white", outlier.alpha = 0) +
  scale_fill_manual(values = c("February" = "#E69F00", "June" = "#56B4E9", "August" = "#009E73")) +
  theme_linedraw(base_size = 14) +
  theme(
    legend.position = "none",
    axis.text.x = element_text(size = 14, angle = 0, hjust = 0.5, colour = "black"),
    axis.text.y = element_text(size = 14, colour = "black"),
    axis.title = element_text(size = 14, colour = "black"),
    plot.title = element_text(size = 16, face = "bold", colour = "black", hjust = 0.5),
    panel.grid.minor = element_blank()
  ) +
  labs(x = "", y = "d'\n(specialization)")

# Compact top row (A,B,C)
network_row <- degree_violin + betweenness_violin + dprime_violin + 
  plot_layout(widths = c(1, 1, 1), heights = 1) &
  theme(plot.margin = margin(10, 5, 15, 5))

# ==========================================
# 2. TRAJECTORY + GO PLOTS (BOTTOM SECTION D)
# ==========================================

# Individual trajectories
trajectory_long <- pair_trajectories %>%
  left_join(features %>% select(pair_id), by = "pair_id") %>%
  pivot_longer(cols = starts_with("TP"), names_to = "timepoint", values_to = "cor") %>%
  mutate(season = recode(timepoint, "TP0" = "February", "TP5" = "June", "TP7" = "August")) %>%
  mutate(season = factor(season, levels = c("February", "June", "August")))

# Cluster means and SE
cluster_stats <- trajectory_long %>%
  group_by(cluster, season) %>%
  summarise(
    mean_cor = mean(cor),
    se_cor = sd(cor) / sqrt(n()),
    .groups = "drop"
  )

# Get top N GO terms per cluster
top_n_terms <- 10
go_data_plot <- seasonal_functions %>%
  filter(ontology == "Biological Processes") %>%
  group_by(cluster) %>%
  arrange(Fisher) %>%
  slice_head(n = top_n_terms) %>%
  ungroup() %>%
  mutate(
    Term_short = str_trunc(Term, width = 50, side = "right"),
    neglog10p = -log10(Fisher)
  )

# Trajectory plots for each cluster (publication styling)
trajectory_plots <- lapply(unique(cluster_stats$cluster), function(clust) {
  traj_data <- trajectory_long %>% filter(cluster == clust)
  stat_data <- cluster_stats %>% filter(cluster == clust)
  
  ggplot() +
    geom_hline(yintercept = 0, linetype = "dotted", color = "black", linewidth = 0.5) +
    geom_line(data = traj_data, aes(x = season, y = cor, group = pair_id), 
              alpha = 0.08, color = "grey60", linewidth = 0.3) +
    geom_ribbon(data = stat_data, aes(x = season, y = mean_cor,
                                      ymin = mean_cor - se_cor, 
                                      ymax = mean_cor + se_cor, group = 1), 
                fill = "red3", alpha = 0.2) +
    geom_line(data = stat_data, aes(x = season, y = mean_cor, group = 1), 
              color = "red3", linewidth = 1.2) +
    geom_point(data = stat_data, aes(x = season, y = mean_cor), 
               color = "red3", size = 3) +
    labs(title = paste0("Cluster ", clust), x = "", y = "Spearman correlation") +
    theme_bw(base_size = 14) +
    theme(
      plot.title = element_text(face = "bold", size = 16, hjust = 0.5, colour = "black"),
      axis.text.x = element_text(size = 14, angle = 0, hjust = 0.5, colour = "black"),
      axis.text.y = element_text(size = 14, colour = "black"),
      axis.title = element_text(size = 14, colour = "black"),
      panel.grid.minor = element_blank()
    )
})

# GO enrichment plots for each cluster (publication styling)
go_plots <- lapply(unique(go_data_plot$cluster), function(clust) {
  go_data <- go_data_plot %>% filter(cluster == clust)
  
  ggplot(go_data, aes(x = neglog10p, y = reorder(Term_short, neglog10p), size = Significant)) + 
    geom_point(alpha = 0.8, colour = "black") + 
    labs(x = expression(-log[10](italic(Fisher))), y = "", size = "Gene Count",
         title = paste("Cluster", clust)) +
    scale_size_continuous(range = c(3, 10)) + 
    theme_bw(base_size = 14) +
    theme(
      plot.title = element_text(face = "bold", size = 16, hjust = 0.5, colour = "black"),
      axis.text.y = element_text(size = 12, colour = "black"),
      axis.text.x = element_text(size = 14, colour = "black"),
      axis.title.x = element_text(size = 14, colour = "black"),
      panel.grid.minor = element_blank(),
      panel.grid.major.y = element_line(linetype = "dotted", color = "gray80")
    )
})

# Combine trajectory + GO for each cluster
n_clusters <- length(unique(cluster_stats$cluster))
cluster_combined <- lapply(1:n_clusters, function(i) {
  trajectory_plots[[i]] + go_plots[[i]] + plot_layout(widths = c(1, 1.2))
})

# Combine ALL clusters vertically  
cluster_row <- wrap_plots(cluster_combined, ncol = 1, heights = rep(1, n_clusters))

# ==========================================
# 3. FINAL PUBLICATION FIGURE WITH A,B,C,D
# ==========================================

final_plot <- network_row / cluster_row + 
  plot_layout(heights = c(0.6, 2.2)) +
  plot_annotation(
    tag_levels = "A")


print(final_plot)

# Save high-quality publication versions
ggsave("../output/Molecular/interactions/networks/seasonal_network_analysis.pdf", 
       final_plot, width = 16, height = 3.5 + 4 * n_clusters, limitsize = FALSE, dpi = 600)
ggsave("../output/Molecular/interactions/networks/seasonal_network_analysis.png", 
       final_plot, width = 16, height = 3.5 + 4 * n_clusters, limitsize = FALSE, dpi = 600)
```



