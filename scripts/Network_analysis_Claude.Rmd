---
title: "More network stuff"
author: "Jill Ashey"
date: "2026-01-26"
output: html_document
---

Trying some more network stuff based on Claude AI stuff. 

Load packages
```{r}
library(tidyverse)
library(DESeq2)
library(igraph)
library(corrplot)
library(pheatmap)
library(ggraph)
library(tidygraph)
library(patchwork)
library(RColorBrewer)
library(ggalluvial)
library(bipartite)
library(parallel)
```

Read in metadata 
```{r}
metadata <- read.csv("../data/Molecular/RNA_metadata.csv")

# Remove AST-1105 -- did not sequence well 
metadata <- metadata %>%
  filter(!ID == "AST-1105") %>%
  rename(sample = ID, timepoint = Timepoint, treatment = Treatment)
```

Load mRNA counts and normalize 
```{r}
mrna_counts <- read_csv("../output/Molecular/mRNA/filtered_gene_counts.csv")
mrna_counts_df <- as.data.frame(mrna_counts)
rownames(mrna_counts_df) <- mrna_counts_df$...1
mrna_counts_df$...1 <- NULL

# Remove AST-1105 -- did not sequence well 
mrna_counts_df <- mrna_counts_df %>%
  select(-"AST-1105")

# Normalize 
dds_mrna <- DESeqDataSetFromMatrix(
  countData = mrna_counts_df,
  colData = metadata,
  design = ~1)
vsd_mrna <- vst(dds_mrna, blind = FALSE)
mrna_norm <- assay(vsd_mrna)
```

Load miRNA counts and normalize 
```{r}
mirna_counts <- read.csv("../output/Molecular/smRNA/shortstack/putative_miRNA_counts.csv") # AST-1105 already removed from the df 
mirna_counts_df <- as.data.frame(mirna_counts)
rownames(mirna_counts_df) <- mirna_counts_df$X
mirna_counts_df$X <- NULL

# Replace . with - in sample names 
colnames(mirna_counts_df) <- ifelse(
  str_starts(colnames(mirna_counts_df), "AST"),
  gsub("\\.", "-", colnames(mirna_counts_df)),
  colnames(mirna_counts_df))

# Normalize 
dds_mirna <- DESeqDataSetFromMatrix(
  countData = mirna_counts_df,
  colData = metadata,
  design = ~1)
vsd_mirna <- varianceStabilizingTransformation(dds_mirna, blind = FALSE)
mirna_norm <- assay(vsd_mirna)
```

Read in miranda data - 1kb 3'UTR binding 
```{r}
miranda_3utr <- read.delim("../output/Molecular/interactions/miranda_strict_all_1kb_apoc_shortstack_parsed.txt", header = F)
colnames(miranda_3utr) <- c("miRNA", "mRNA", "score", "energy", "query_start_end", "subject_start_end", "total_bp_shared", "query_similar", "subject_similar")

# Format miranda df
miranda_3utr$miRNA <- sub("^>", "", miranda_3utr$miRNA)  # Remove leading ">"
miranda_3utr$miRNA <- sub("\\..*", "", miranda_3utr$miRNA)  # Remove everything from the first period onwards
miranda_3utr$mRNA <- sub(";.*", "", miranda_3utr$mRNA)  # Remove everything from "::" onwards
miranda_3utr$mRNA <- sub("ID=", "", miranda_3utr$mRNA)  # Remove everything from "::" onwards

dim(miranda_3utr)
length(unique(miranda_3utr$miRNA))
length(unique(miranda_3utr$mRNA))

# Calculate length of binding 
miranda_3utr <- miranda_3utr %>%
  separate(query_start_end, into = c("start", "end"), sep = " ", convert = TRUE) %>%
  mutate(interaction_length = end - start)
miranda_3utr$binding_type <- "3'UTR"
```

Read in miranda data - entire mRNA binding
```{r}
miranda_mrna <- read.delim("~/Desktop/PutnamLab/Astrangia/Molecular/miranda_strict_all_mrna_apoc_shortstack_parsed.txt", header = F)
colnames(miranda_mrna) <- c("miRNA", "mRNA", "score", "energy", "query_start_end", "subject_start_end", "total_bp_shared", "query_similar", "subject_similar")

# Format miranda df 
miranda_mrna$miRNA <- sub("^>", "", miranda_mrna$miRNA)  # Remove leading ">"
miranda_mrna$miRNA <- sub("\\..*", "", miranda_mrna$miRNA)  # Remove everything from the first period onwards
miranda_mrna$mRNA <- sub(";.*", "", miranda_mrna$mRNA)  # Remove everything from "::" onwards
miranda_mrna$mRNA <- sub("ID=", "", miranda_mrna$mRNA)  # Remove everything from "::" onwards
miranda_mrna$mRNA <- sub("model", "TU", miranda_mrna$mRNA)  # Remove everything from "::" onwards

dim(miranda_mrna)
length(unique(miranda_mrna$miRNA))
length(unique(miranda_mrna$mRNA))

# Calculate length of binding 
miranda_mrna <- miranda_mrna %>%
  separate(query_start_end, into = c("start", "end"), sep = " ", convert = TRUE) %>%
  mutate(interaction_length = end - start) 
miranda_mrna$binding_type <- "CDS"
```

Bind miranda dfs and filter so that interaction length must be at least 13 bp
```{r}
miranda_data <- rbind(miranda_3utr, miranda_mrna)

# Filter interaction length 
miranda_data <- miranda_data %>%
  filter(interaction_length >= 13) 
miranda_data <- unique(miranda_data)
```

Check data 
```{r}
cat("=== DATA DIMENSIONS ===\n")
cat("mRNA genes:", nrow(mrna_counts_df), "\n")
cat("mRNA samples:", ncol(mrna_counts_df), "\n")
cat("miRNA:", nrow(mirna_counts_df), "\n")
cat("miRNA samples:", ncol(mirna_counts_df), "\n")
cat("Metadata rows:", nrow(metadata), "\n")
cat("Predicted interactions:", nrow(miranda_data), "\n\n")

# Check that sample names match
cat("=== SAMPLE NAME CHECK ===\n")
cat("Samples in mRNA data:", paste(colnames(mrna_counts_df), collapse = ", "), "...\n")
cat("Samples in miRNA data:", paste(colnames(mirna_counts_df), collapse = ", "), "...\n")
cat("Samples in metadata:", paste(metadata$sample), collapse = ", ", "...\n\n")

# Check if all samples match
all_match <- all(colnames(mrna_counts_df) == metadata$sample) & 
             all(colnames(mirna_counts_df) == metadata$sample)
cat("Do all samples match? ", all_match, "\n\n")

cat("=== INTERACTION PREDICTIONS ===\n")
cat("Column names in interactions:", paste(colnames(miranda_data), collapse = ", "), "\n")
head(miranda_data)
table(miranda_data$binding_type)
```

Normalize counts and check interactions
```{r}
# ==========================================
# STEP 1D: Reorder samples to match metadata
# ==========================================

# Reorder count matrices to match metadata sample order
mrna_counts <- mrna_counts_df[, metadata$sample]
mirna_counts <- mirna_counts_df[, metadata$sample]

# Verify they match now
cat("=== VERIFY SAMPLE ORDER ===\n")
cat("Do samples match now? ", 
    all(colnames(mrna_counts) == metadata$sample) & 
    all(colnames(mirna_counts) == metadata$sample), "\n\n")

# ==========================================
# STEP 1E: Check interaction data
# ==========================================

cat("=== INTERACTION BREAKDOWN ===\n")
cat("Total predicted interactions:", nrow(miranda_data), "\n")
cat("  3'UTR interactions:", sum(miranda_data$binding_type == "3'UTR"), "\n")
cat("  CDS interactions:", sum(miranda_data$binding_type == "CDS"), "\n\n")

# How many unique miRNAs and mRNAs in predictions?
cat("Unique miRNAs in predictions:", length(unique(miranda_data$miRNA)), "\n")
cat("Unique mRNAs in predictions:", length(unique(miranda_data$mRNA)), "\n\n")

# Are all predicted miRNAs in your count data?
mirnas_in_predictions <- unique(miranda_data$miRNA)
mirnas_in_counts <- rownames(mirna_counts)
cat("miRNAs in predictions but not in counts:", 
    sum(!mirnas_in_predictions %in% mirnas_in_counts), "\n")

# Are all predicted mRNAs in your count data?
mrnas_in_predictions <- unique(miranda_data$mRNA)
mrnas_in_counts <- rownames(mrna_counts)
cat("mRNAs in predictions but not in counts:", 
    sum(!mrnas_in_predictions %in% mrnas_in_counts), "\n\n")

# ==========================================
# STEP 1F: Normalize counts
# ==========================================

cat("=== NORMALIZING DATA ===\n")

# mRNA normalization
cat("Normalizing mRNA data...\n")
dds_mrna <- DESeqDataSetFromMatrix(
  countData = mrna_counts,
  colData = metadata,
  design = ~ 1
)

# Variance stabilizing transformation
vsd_mrna <- vst(dds_mrna, blind = FALSE)
mrna_norm <- assay(vsd_mrna)

cat("mRNA normalization complete.\n\n")

# miRNA normalization
cat("Normalizing miRNA data...\n")
dds_mirna <- DESeqDataSetFromMatrix(
  countData = mirna_counts,
  colData = metadata,
  design = ~ 1
)

vsd_mirna <- varianceStabilizingTransformation(dds_mirna, blind = FALSE)
mirna_norm <- assay(vsd_mirna)

cat("miRNA normalization complete.\n\n")

# ==========================================
# STEP 1G: Basic expression QC
# ==========================================

cat("=== EXPRESSION SUMMARY ===\n")

# Mean expression per miRNA (across all samples)
mirna_mean_expr <- rowMeans(mirna_norm)
cat("miRNA expression range:", round(min(mirna_mean_expr), 2), "to", 
    round(max(mirna_mean_expr), 2), "\n")

# How many miRNAs are highly expressed?
high_expr_mirnas <- names(mirna_mean_expr)[mirna_mean_expr > median(mirna_mean_expr)]
cat("Highly expressed miRNAs (above median):", length(high_expr_mirnas), "\n")

# ==========================================
# STEP 1H: Filter low-variance features
# ==========================================

cat("=== FILTERING LOW-VARIANCE FEATURES ===\n")

# Calculate variance for each feature
mrna_var <- apply(mrna_norm, 1, var)
mirna_var <- apply(mirna_norm, 1, var)

# Set minimum variance threshold (you can adjust this)
min_var_threshold <- 0.01

# Filter
mrna_keep <- names(mrna_var)[mrna_var > min_var_threshold & !is.na(mrna_var)]
mirna_keep <- names(mirna_var)[mirna_var > min_var_threshold & !is.na(mirna_var)]

cat("mRNAs passing variance filter:", length(mrna_keep), "of", nrow(mrna_norm), "\n")
cat("miRNAs passing variance filter:", length(mirna_keep), "of", nrow(mirna_norm), "\n\n")

# Create filtered versions
mrna_norm_filtered <- mrna_norm[mrna_keep, ]
mirna_norm_filtered <- mirna_norm[mirna_keep, ]

# Filter interactions to only include genes/miRNAs that passed filters
interactions_filtered <- miranda_data %>%
  filter(miRNA %in% mirna_keep, mRNA %in% mrna_keep)

cat("Interactions after filtering:", nrow(interactions_filtered), "of", nrow(miranda_data), "\n\n")

# ==========================================
# STEP 1I: Summary of what we'll analyze
# ==========================================

cat("=== READY FOR ANALYSIS ===\n")
cat("miRNAs to analyze:", length(mirna_keep), "\n")
cat("mRNAs to analyze:", length(mrna_keep), "\n")
cat("Predicted interactions to test:", nrow(interactions_filtered), "\n")
cat("  3'UTR:", sum(interactions_filtered$binding_type == "3'UTR"), "\n")
cat("  CDS:", sum(interactions_filtered$binding_type == "CDS"), "\n")
cat("\nSamples per condition:\n")
print(table(metadata$timepoint, metadata$treatment))
```

miR-100 = Cluster 2003
miR-2022 = Cluster_3853
miR-2025 = Cluster_1340
miR-2036 = Cluster_1772

```{r}
# ==========================================
# STEP 1J: Save processed data
# ==========================================

# Save normalized data and filtered interactions
# saveRDS(mrna_norm_filtered, "mrna_normalized.rds")
# saveRDS(mirna_norm_filtered, "mirna_normalized.rds")
# saveRDS(interactions_filtered, "interactions_filtered.rds")
# saveRDS(metadata, "metadata.rds")
# 
# cat("Data saved!\n\n")

# ==========================================
# STEP 1K: Quick QC visualization
# ==========================================

# PCA to see if samples cluster by timepoint
# (Just to confirm your seasonal pattern exists in the data)

# For miRNA
pca_mirna <- prcomp(t(mirna_norm_filtered), scale. = TRUE)
pca_mirna_df <- as.data.frame(pca_mirna$x[, 1:2]) %>%
  rownames_to_column("sample") %>%
  left_join(metadata, by = "sample")

# Variance explained
var_explained_mirna <- round(100 * summary(pca_mirna)$importance[2, 1:2], 1)

# Plot
p1 <- ggplot(pca_mirna_df, aes(x = PC1, y = PC2, color = timepoint, shape = treatment)) +
  geom_point(size = 4) +
  theme_minimal() +
  labs(
    title = "miRNA expression - PCA",
    x = paste0("PC1 (", var_explained_mirna[1], "%)"),
    y = paste0("PC2 (", var_explained_mirna[2], "%)")
  ) +
  scale_color_manual(values = c("TP0" = "#3B4CC0", "TP5" = "#B40426", "TP7" = "#F0E442"))

print(p1)

# Sample correlation heatmap for miRNA
sample_cor_mirna <- cor(mirna_norm_filtered, method = "spearman")

# Annotation for heatmap
annotation_col <- metadata %>%
  select(sample, timepoint, treatment) %>%
  column_to_rownames("sample")

pheatmap(sample_cor_mirna,
         annotation_col = annotation_col,
         annotation_row = annotation_col,
         main = "Sample-to-sample correlation (miRNA)",
         show_rownames = FALSE,
         show_colnames = FALSE)

# ==========================================
# STEP 1L: Expression of key miRNAs
# ==========================================

# Look at your key miRNAs across conditions
# miR-100 = Cluster_2003
# miR-2022 = Cluster_3853
# miR-2025 = Cluster_1340
# miR-2036 = Cluster_1772
key_mirnas <- c("Cluster_2003", "Cluster_3853", "Cluster_1340", "Cluster_1772")
key_present <- key_mirnas[key_mirnas %in% rownames(mirna_norm_filtered)]

if (length(key_present) > 0) {
  
  # Get expression data for key miRNAs
  key_expr <- mirna_norm_filtered[key_present, , drop = FALSE] %>%
    as.data.frame() %>%
    rownames_to_column("miRNA") %>%
    pivot_longer(-miRNA, names_to = "sample", values_to = "expression") %>%
    left_join(metadata, by = "sample")
  
  # Plot
  p2 <- ggplot(key_expr, aes(x = timepoint, y = expression, color = treatment)) +
    geom_point(size = 3, position = position_jitter(width = 0.1)) +
    facet_wrap(~miRNA, scales = "free_y") +
    theme_minimal() +
    labs(
      title = "Expression of key miRNAs",
      y = "Normalized expression (VST)"
    )
  
  print(p2)
  
} else {
  cat("Key miRNAs not found in data. Check miRNA names.\n")
  cat("Available miRNAs:\n")
  print(head(rownames(mirna_norm_filtered), 20))
}
```

Correlation time! 
```{r}
# Load saved objects (if starting fresh)
# mrna_norm_filtered <- readRDS("mrna_normalized.rds")
# mirna_norm_filtered <- readRDS("mirna_normalized.rds")
# interactions_filtered <- readRDS("interactions_filtered.rds")
# metadata <- readRDS("metadata.rds")

# Function to calculate correlations for one condition
calculate_condition_correlations <- function(mrna_data, mirna_data, 
                                             interactions_df,
                                             metadata, 
                                             timepoint_val, 
                                             treatment_val,
                                             min_cor_threshold = 0.3) {
  
  cat("Processing:", timepoint_val, "-", treatment_val, "\n")
  
  # Get samples for this condition
  samples <- metadata %>% 
    filter(timepoint == timepoint_val, treatment == treatment_val) %>% 
    pull(sample)
  
  n_samples <- length(samples)
  cat("  N samples:", n_samples, "\n")
  
  # Subset data to these samples
  mrna_subset <- mrna_data[, samples, drop = FALSE]
  mirna_subset <- mirna_data[, samples, drop = FALSE]
  
  # Calculate correlations only for predicted interactions
  cat("  Calculating", nrow(interactions_df), "correlations...\n")
  
  correlations <- interactions_df %>%
    rowwise() %>%
    mutate(
      # Calculate correlation
      cor_value = cor(mrna_subset[mRNA, ], 
                     mirna_subset[miRNA, ], 
                     method = "spearman"),
      # Calculate p-value
      p_value = tryCatch({
        cor.test(mrna_subset[mRNA, ], 
                mirna_subset[miRNA, ], 
                method = "spearman")$p.value
      }, error = function(e) NA_real_),
      # Add metadata
      timepoint = timepoint_val,
      treatment = treatment_val,
      n_samples = n_samples
    ) %>%
    ungroup() %>%
    filter(!is.na(cor_value), !is.na(p_value))
  
  cat("  Done! Valid correlations:", nrow(correlations), "\n\n")
  
  return(correlations)
}

# ==========================================
# STEP 2B: Calculate for all conditions
# ==========================================

cat("=== CALCULATING CORRELATIONS FOR ALL CONDITIONS ===\n\n")

all_correlations <- bind_rows(
  calculate_condition_correlations(
    mrna_norm_filtered, mirna_norm_filtered, 
    interactions_filtered, metadata,
    "TP0", "Acclimation"
  ),
  calculate_condition_correlations(
    mrna_norm_filtered, mirna_norm_filtered, 
    interactions_filtered, metadata,
    "TP5", "Ambient"
  ),
  calculate_condition_correlations(
    mrna_norm_filtered, mirna_norm_filtered, 
    interactions_filtered, metadata,
    "TP5", "Heat"
  ),
  calculate_condition_correlations(
    mrna_norm_filtered, mirna_norm_filtered, 
    interactions_filtered, metadata,
    "TP7", "Ambient"
  ),
  calculate_condition_correlations(
    mrna_norm_filtered, mirna_norm_filtered, 
    interactions_filtered, metadata,
    "TP7", "Heat"
  )
)

# ==========================================
# STEP 2C: Multiple testing correction
# ==========================================

cat("=== APPLYING MULTIPLE TESTING CORRECTION ===\n")

all_correlations <- all_correlations %>%
  mutate(
    p_adj = p.adjust(p_value, method = "BH"),
    pair_id = paste(miRNA, mRNA, sep = "_")
  )

cat("Total correlation tests:", nrow(all_correlations), "\n")
cat("Significant at FDR < 0.05:", sum(all_correlations$p_adj < 0.05), "\n")
cat("Significant at FDR < 0.01:", sum(all_correlations$p_adj < 0.01), "\n\n")

# ==========================================
# STEP 2D: Summary statistics
# ==========================================

cat("=== SUMMARY BY CONDITION ===\n")

summary_by_condition <- all_correlations %>%
  group_by(timepoint, treatment, n_samples) %>%
  summarise(
    n_tested = n(),
    n_sig_05 = sum(p_adj < 0.05),
    n_sig_01 = sum(p_adj < 0.01),
    prop_sig = n_sig_05 / n_tested,
    mean_abs_cor = mean(abs(cor_value)),
    median_cor = median(cor_value),
    n_negative = sum(cor_value < 0 & p_adj < 0.05),
    n_positive = sum(cor_value > 0 & p_adj < 0.05),
    prop_negative_of_sig = n_negative / n_sig_05,
    .groups = "drop"
  )

print(summary_by_condition)

# Save summary
#write_csv(summary_by_condition, "correlation_summary_by_condition.csv")

# ==========================================
# STEP 2E: Save results
# ==========================================

#saveRDS(all_correlations, "all_correlations.rds")
#write.csv(all_correlations, "../output/Molecular/interactions/networks/all_spearman_correlations_by_conditions.csv")
all_correlations <- read.csv("../output/Molecular/interactions/networks/all_spearman_correlations_by_conditions.csv")

#cat("\n=== DATA SAVED ===\n")
#cat("Saved to: all_correlations.rds and all_correlations.csv\n\n")

# ==========================================
# STEP 2F: Quick visualizations
# ==========================================

# Distribution of correlations by condition
p1 <- ggplot(all_correlations, 
             aes(x = cor_value, fill = timepoint)) +
  geom_density(alpha = 0.6) +
  facet_wrap(~treatment, ncol = 1) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme_minimal() +
  labs(
    subtitle = "Predicted miRNA-mRNA interactions",
    x = "Spearman correlation",
    y = "Density"
  ) +
  scale_fill_manual(values = c("TP0" = "#3B4CC0", "TP5" = "#B40426", "TP7" = "#F0E442"))

print(p1)

# Negative vs positive correlations
all_correlations <- all_correlations %>%
  mutate(cor_type = ifelse(cor_value < 0, "Negative", "Positive")) %>%
  count(timepoint, treatment, cor_type)

p2 <- all_correlations %>%
  #filter(p_adj < 0.05) %>%
  mutate(cor_type = ifelse(cor_value < 0, "Negative", "Positive")) %>%
  dplyr::count(timepoint, treatment, cor_type) %>%
  ggplot(aes(x = timepoint, y = n, fill = cor_type)) +
  geom_col(position = "dodge") +
  facet_wrap(~treatment) +
  theme_minimal() +
  labs(
    title = "Negative vs Positive correlations",
    y = "Number of interactions",
    fill = "Correlation"
  ) +
  scale_fill_manual(values = c("Negative" = "#377EB8", "Positive" = "#E41A1C"))

print(p2)

# Correlation strength by binding type
p3 <- all_correlations %>%
  #filter(p_adj < 0.05) %>%
  ggplot(aes(x = binding_type, y = abs(cor_value), fill = binding_type)) +
  geom_boxplot() +
  facet_wrap(~timepoint) +
  theme_minimal() +
  labs(
    title = "Correlation strength by binding type",
    subtitle = "3'UTR vs CDS predictions",
    y = "|Spearman correlation|",
    x = ""
  ) +
  theme(legend.position = "none")

print(p3)
```

Using correlation strength instead of pvalue as a cutoff
```{r}
# ==========================================
# STEP 3A: Define correlation strength categories
# ==========================================

cat("=== CLASSIFYING CORRELATIONS BY STRENGTH ===\n\n")

# Add categories based on correlation strength
all_correlations_classified <- all_correlations %>%
  mutate(
    # Correlation strength category
    cor_strength = case_when(
      abs(cor_value) >= 0.7 ~ "Strong",
      abs(cor_value) >= 0.5 ~ "Moderate",
      abs(cor_value) >= 0.3 ~ "Weak",
      TRUE ~ "Very weak"
    ),
    # Direction
    cor_direction = case_when(
      cor_value < -0.5 ~ "Strong negative",
      cor_value < 0 ~ "Weak negative", 
      cor_value > 0.5 ~ "Strong positive",
      TRUE ~ "Weak positive"
    ),
    # Simple direction
    direction = ifelse(cor_value < 0, "Negative", "Positive")
  )

# Summary by strength
strength_summary <- all_correlations_classified %>%
  dplyr::count(timepoint, treatment, cor_strength, direction) %>%
  pivot_wider(names_from = direction, values_from = n, values_fill = 0) %>%
  arrange(timepoint, treatment, cor_strength)

cat("Correlation strength distribution:\n")
print(strength_summary)

# ==========================================
# STEP 3B: Focus on strong correlations
# ==========================================

# Define threshold for "strong" correlation
strong_threshold <- 0.6  # You can adjust this

strong_correlations <- all_correlations_classified %>%
  filter(abs(cor_value) >= strong_threshold)

cat("\n=== STRONG CORRELATIONS (|r| >=", strong_threshold, ") ===\n")
cat("Total strong correlations:", nrow(strong_correlations), "\n")

strong_summary <- strong_correlations %>%
  group_by(timepoint, treatment) %>%
  summarise(
    n_strong = n(),
    n_negative = sum(cor_value < 0),
    n_positive = sum(cor_value > 0),
    prop_negative = n_negative / n_strong,
    mean_cor = mean(cor_value),
    .groups = "drop"
  )

print(strong_summary)

# By binding type
strong_by_type <- strong_correlations %>%
  dplyr::count(timepoint, treatment, binding_type, direction) %>%
  pivot_wider(names_from = direction, values_from = n, values_fill = 0)

cat("\nStrong correlations by binding type:\n")
print(strong_by_type)

# ==========================================
# STEP 3C: Identify interaction patterns across conditions
# ==========================================

cat("\n=== ANALYZING PATTERNS ACROSS CONDITIONS ===\n")

# For each miRNA-mRNA pair, get correlations across all conditions
interaction_patterns <- all_correlations_classified %>%
  group_by(miRNA, mRNA, pair_id, binding_type) %>%
  summarise(
    # How many conditions tested
    n_conditions = n(),
    
    # Correlation statistics across conditions
    mean_cor = mean(cor_value),
    sd_cor = sd(cor_value),
    min_cor = min(cor_value),
    max_cor = max(cor_value),
    range_cor = max_cor - min_cor,
    
    # How many are strong
    n_strong = sum(abs(cor_value) >= strong_threshold),
    
    # Direction consistency
    all_negative = all(cor_value < 0),
    all_positive = all(cor_value > 0),
    switches_sign = any(cor_value > 0) & any(cor_value < 0),
    
    # Predominant direction
    mostly_negative = sum(cor_value < 0) >= 3,
    mostly_positive = sum(cor_value > 0) >= 3,
    
    .groups = "drop"
  )

# ==========================================
# STEP 3D: Classify interaction types
# ==========================================

interaction_classified <- interaction_patterns %>%
  mutate(
    interaction_type = case_when(
      # Constitutive strong repression
      all_negative & n_strong >= 3 ~ "Constitutive repression",
      
      # Constitutive activation/co-regulation
      all_positive & n_strong >= 3 ~ "Constitutive activation",
      
      # Mostly negative with strong correlation
      mostly_negative & n_strong >= 2 ~ "Predominantly repressive",
      
      # Mostly positive
      mostly_positive & n_strong >= 2 ~ "Predominantly activating",
      
      # Sign switching (very dynamic)
      switches_sign & max(abs(c(min_cor, max_cor))) >= 0.5 ~ "Context-dependent",
      
      # Large range (dynamic but same sign)
      range_cor >= 0.7 & !switches_sign ~ "Dynamic regulation",
      
      # Weak/inconsistent
      TRUE ~ "Weak/variable"
    )
  )

# Summary of interaction types
type_summary <- interaction_classified %>%
  dplyr::count(interaction_type, binding_type) %>%
  arrange(desc(n))

cat("\nInteraction types identified:\n")
print(type_summary)

# ==========================================
# STEP 3E: Focus on biologically interesting patterns
# ==========================================

# Constitutive repressors (canonical miRNA behavior)
constitutive_repression <- interaction_classified %>%
  filter(interaction_type == "Constitutive repression") %>%
  arrange(mean_cor)

cat("\n=== CONSTITUTIVE REPRESSION ===\n")
cat("N interactions:", nrow(constitutive_repression), "\n")
if(nrow(constitutive_repression) > 0) {
  cat("\nTop 10 strongest:\n")
  print(head(constitutive_repression %>% select(miRNA, mRNA, mean_cor, binding_type), 10))
}

# Context-dependent (most interesting for seasonal story!)
context_dependent <- interaction_classified %>%
  filter(interaction_type == "Context-dependent") %>%
  arrange(desc(range_cor))

cat("\n=== CONTEXT-DEPENDENT REGULATION ===\n")
cat("N interactions:", nrow(context_dependent), "\n")
if(nrow(context_dependent) > 0) {
  cat("\nTop 10 most dynamic:\n")
  print(head(context_dependent %>% select(miRNA, mRNA, min_cor, max_cor, range_cor, binding_type), 10))
}

# Dynamic regulation (same direction, big changes)
dynamic_regulation <- interaction_classified %>%
  filter(interaction_type == "Dynamic regulation") %>%
  arrange(desc(range_cor))

cat("\n=== DYNAMIC REGULATION ===\n")
cat("N interactions:", nrow(dynamic_regulation), "\n")
if(nrow(dynamic_regulation) > 0) {
  cat("\nTop 10:\n")
  print(head(dynamic_regulation %>% select(miRNA, mRNA, min_cor, max_cor, range_cor, binding_type), 10))
}

# ==========================================
# STEP 3F: Save classified results
# ==========================================

# saveRDS(all_correlations_classified, "correlations_classified.rds")
# saveRDS(interaction_classified, "interaction_patterns.rds")
# 
# write_csv(all_correlations_classified, "correlations_classified.csv")
# write_csv(interaction_classified, "interaction_patterns.csv")
# 
# # Save specific types for follow-up
# write_csv(constitutive_repression, "constitutive_repression.csv")
# write_csv(context_dependent, "context_dependent.csv")
# write_csv(dynamic_regulation, "dynamic_regulation.csv")
# 
# cat("\n=== FILES SAVED ===\n")
```

Visualizing patterns
```{r}
# ==========================================
# STEP 4A: Detailed look at correlation patterns
# ==========================================

# Get the full correlation data for each interaction type
interaction_details <- all_correlations_classified %>%
  left_join(
    interaction_classified %>% select(pair_id, interaction_type, range_cor),
    by = "pair_id"
  )

# ==========================================
# STEP 4B: Heatmap of context-dependent interactions
# ==========================================

# Get top context-dependent interactions
top_context_dependent <- context_dependent %>%
  slice_max(range_cor, n = 50) %>%
  pull(pair_id)

# Get their correlations across conditions
context_dep_cors <- all_correlations_classified %>%
  filter(pair_id %in% top_context_dependent) %>%
  mutate(condition = paste(timepoint, treatment, sep = "_")) %>%
  select(pair_id, condition, cor_value) %>%
  pivot_wider(names_from = condition, values_from = cor_value) %>%
  column_to_rownames("pair_id")

# Plot heatmap
library(pheatmap)

pheatmap(context_dep_cors,
         color = colorRampPalette(c("blue", "white", "red"))(100),
         breaks = seq(-1, 1, length.out = 101),
         cluster_cols = FALSE,
         main = "Top 50 context-dependent interactions",
         fontsize_row = 6,
         show_rownames = TRUE)

# ==========================================
# STEP 4C: Examples of each interaction type
# ==========================================

# Function to plot individual interaction patterns
plot_interaction_pattern <- function(mirna, mrna, cor_data) {
  
  data_to_plot <- cor_data %>%
    filter(miRNA == mirna, mRNA == mrna) %>%
    mutate(condition = paste(timepoint, treatment, sep = "\n"))
  
  ggplot(data_to_plot, aes(x = condition, y = cor_value)) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
    geom_line(aes(group = 1), linewidth = 1) +
    geom_point(size = 4, aes(color = cor_value)) +
    scale_color_gradient2(low = "blue", mid = "white", high = "red", 
                         midpoint = 0, limits = c(-1, 1)) +
    theme_minimal() +
    labs(
      title = paste(mirna, "→", mrna),
      y = "Spearman correlation",
      x = ""
    ) +
    theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
}

# Plot examples of each type
# Constitutive repression
if (nrow(constitutive_repression) > 0) {
  example <- constitutive_repression[1, ]
  p1 <- plot_interaction_pattern(example$miRNA, example$mRNA, all_correlations_classified)
  print(p1)
  #ggsave("example_constitutive_repression.pdf", width = 6, height = 4)
}

# Context-dependent
if (nrow(context_dependent) > 0) {
  example <- context_dependent[1, ]
  p2 <- plot_interaction_pattern(example$miRNA, example$mRNA, all_correlations_classified)
  print(p2)
  #ggsave("example_context_dependent.pdf", width = 6, height = 4)
}

# ==========================================
# STEP 4D: Fixed seasonal pattern analysis
# ==========================================

# We need to compare across timepoints, but treatment changes
# TP0 = Acclimation (baseline)
# TP5 = Ambient or Heat
# TP7 = Ambient or Heat

# Strategy: Compare ambient conditions only (TP5 & TP7)
# And use TP0 as baseline

# First, get TP0 correlations (baseline)
tp0_correlations <- all_correlations_classified %>%
  filter(timepoint == "TP0") %>%
  select(miRNA, mRNA, pair_id, cor_TP0 = cor_value, binding_type)

# Get TP5 Ambient
tp5_ambient <- all_correlations_classified %>%
  filter(timepoint == "TP5", treatment == "Ambient") %>%
  select(miRNA, mRNA, pair_id, cor_TP5_Ambient = cor_value)

# Get TP7 Ambient
tp7_ambient <- all_correlations_classified %>%
  filter(timepoint == "TP7", treatment == "Ambient") %>%
  select(miRNA, mRNA, pair_id, cor_TP7_Ambient = cor_value)

# Combine - seasonal progression under ambient conditions
seasonal_pattern <- tp0_correlations %>%
  left_join(tp5_ambient, by = c("miRNA", "mRNA", "pair_id")) %>%
  left_join(tp7_ambient, by = c("miRNA", "mRNA", "pair_id")) %>%
  mutate(
    # Changes between timepoints
    change_TP0_to_TP5 = cor_TP5_Ambient - cor_TP0,
    change_TP5_to_TP7 = cor_TP7_Ambient - cor_TP5_Ambient,
    change_TP0_to_TP7 = cor_TP7_Ambient - cor_TP0,
    
    # Maximum absolute change
    max_change = pmax(
      abs(change_TP0_to_TP5), 
      abs(change_TP5_to_TP7),
      abs(change_TP0_to_TP7),
      na.rm = TRUE
    )
  )

# Check the structure
cat("=== SEASONAL PATTERN DATA ===\n")
cat("Total interactions:", nrow(seasonal_pattern), "\n")
cat("Complete data (all 3 timepoints):", sum(complete.cases(seasonal_pattern)), "\n\n")

# Look at big seasonal changes
big_seasonal_changes <- seasonal_pattern %>%
  filter(complete.cases(.)) %>%  # Only keep complete data
  filter(max_change > 0.7) %>%
  arrange(desc(max_change))

cat("=== BIG SEASONAL CHANGES (ambient conditions) ===\n")
cat("N interactions with |Δr| > 0.7:", nrow(big_seasonal_changes), "\n\n")

if (nrow(big_seasonal_changes) > 0) {
  cat("Top 10:\n")
  print(head(big_seasonal_changes %>% 
             select(miRNA, mRNA, cor_TP0, cor_TP5_Ambient, cor_TP7_Ambient, 
                    max_change, binding_type), 10))
}

# Summary statistics
seasonal_summary <- seasonal_pattern %>%
  filter(complete.cases(.)) %>%
  summarise(
    n_total = n(),
    mean_change_TP0_to_TP5 = mean(abs(change_TP0_to_TP5)),
    mean_change_TP5_to_TP7 = mean(abs(change_TP5_to_TP7)),
    mean_change_TP0_to_TP7 = mean(abs(change_TP0_to_TP7)),
    n_big_change = sum(max_change > 0.7),
    n_moderate_change = sum(max_change > 0.5 & max_change <= 0.7)
  )

cat("\n=== SEASONAL CHANGE SUMMARY ===\n")
print(seasonal_summary)
```

```{r}
# ==========================================
# ANSWER QUESTION 1: Complete data across timepoints
# ==========================================

# How many interactions have data at all 3 timepoints?
n_complete <- seasonal_pattern %>%
  filter(!is.na(cor_TP0) & !is.na(cor_TP5_Ambient) & !is.na(cor_TP7_Ambient)) %>%
  nrow()

cat("Q1: Interactions with complete data (all 3 timepoints):", n_complete, "\n\n")

# ==========================================
# ANSWER QUESTION 2: Big seasonal changes
# ==========================================

# Count interactions with big changes (|Δr| > 0.7)
big_changes <- seasonal_pattern %>%
  filter(!is.na(max_change)) %>%  # Remove NAs
  filter(max_change > 0.7)

n_big_changes <- nrow(big_changes)

cat("Q2: Interactions with BIG seasonal changes (|Δr| > 0.7):", n_big_changes, "\n\n")

# Show some examples
cat("Examples of big seasonal changes:\n")
print(head(big_changes %>% 
           select(miRNA, mRNA, cor_TP0, cor_TP5_Ambient, cor_TP7_Ambient, max_change), 10))

# ==========================================
# ANSWER QUESTION 3: Which transition is bigger?
# ==========================================

# Compare the magnitude of changes between transitions
transition_comparison <- seasonal_pattern %>%
  filter(!is.na(change_TP0_to_TP5) & !is.na(change_TP5_to_TP7)) %>%
  summarise(
    # Average absolute change for each transition
    mean_change_Feb_to_June = mean(abs(change_TP0_to_TP5)),
    mean_change_June_to_Aug = mean(abs(change_TP5_to_TP7)),
    mean_change_Feb_to_Aug = mean(abs(change_TP0_to_TP7)),
    
    # How many show bigger change in each period
    n_bigger_change_Feb_to_June = sum(abs(change_TP0_to_TP5) > abs(change_TP5_to_TP7)),
    n_bigger_change_June_to_Aug = sum(abs(change_TP5_to_TP7) > abs(change_TP0_to_TP5)),
    
    # Total tested
    n_total = n()
  )

cat("\nQ3: Which seasonal transition shows bigger changes?\n")
print(transition_comparison)

cat("\nInterpretation:\n")
cat("- If mean_change_Feb_to_June > mean_change_June_to_Aug: Winter→Summer transition is bigger\n")
cat("- If mean_change_June_to_Aug > mean_change_Feb_to_June: Summer→Late summer transition is bigger\n\n")

# ==========================================
# BONUS: Visualize the patterns
# ==========================================

# Distribution of changes
library(ggplot2)

change_data <- seasonal_pattern %>%
  filter(!is.na(change_TP0_to_TP5) & !is.na(change_TP5_to_TP7)) %>%
  select(pair_id, change_TP0_to_TP5, change_TP5_to_TP7) %>%
  pivot_longer(cols = c(change_TP0_to_TP5, change_TP5_to_TP7),
               names_to = "transition",
               values_to = "change") %>%
  mutate(transition = recode(transition,
                             "change_TP0_to_TP5" = "Feb → June",
                             "change_TP5_to_TP7" = "June → Aug"))

p1 <- ggplot(change_data, aes(x = change, fill = transition)) +
  geom_density(alpha = 0.6) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme_minimal() +
  labs(
    title = "Seasonal changes in miRNA-mRNA correlations",
    x = "Change in correlation (Δr)",
    y = "Density",
    fill = "Transition"
  )

print(p1)

# Box plot comparison
p2 <- ggplot(change_data, aes(x = transition, y = abs(change), fill = transition)) +
  geom_boxplot() +
  theme_minimal() +
  labs(
    title = "Magnitude of seasonal changes",
    x = "",
    y = "|Change in correlation|",
    fill = ""
  ) +
  theme(legend.position = "none")

print(p2)

# ==========================================
# DETAILED BREAKDOWN
# ==========================================

# Categorize the seasonal patterns
seasonal_categories <- seasonal_pattern %>%
  filter(!is.na(max_change)) %>%
  mutate(
    pattern = case_when(
      # Big increase over time
      change_TP0_to_TP7 > 0.7 ~ "Strong increase",
      # Big decrease over time  
      change_TP0_to_TP7 < -0.7 ~ "Strong decrease",
      # U-shape (decreases then increases)
      change_TP0_to_TP5 < -0.5 & change_TP5_to_TP7 > 0.5 ~ "U-shape",
      # Inverted U (increases then decreases)
      change_TP0_to_TP5 > 0.5 & change_TP5_to_TP7 < -0.5 ~ "Inverted U",
      # Relatively stable
      max_change < 0.3 ~ "Stable",
      # Everything else
      TRUE ~ "Variable"
    )
  )

cat("\n=== SEASONAL PATTERN CATEGORIES ===\n")
pattern_counts <- table(seasonal_categories$pattern)
print(pattern_counts)

cat("\nExamples of each pattern type:\n")
for (pattern_type in names(pattern_counts)) {
  examples <- seasonal_categories %>%
    filter(pattern == pattern_type) %>%
    head(3) %>%
    select(miRNA, mRNA, cor_TP0, cor_TP5_Ambient, cor_TP7_Ambient, pattern)
  
  if (nrow(examples) > 0) {
    cat("\n", pattern_type, ":\n")
    print(examples)
  }
}
```

```{r}
# ==========================================
# VISUALIZATION 1: Summary bar chart with examples
# ==========================================

library(tidyverse)
library(patchwork)
library(ggrepel)

# A. Overall pattern distribution
p_summary <- seasonal_categories %>%
  dplyr::count(pattern) %>%
  mutate(pattern = fct_reorder(pattern, n)) %>%
  ggplot(aes(x = pattern, y = n, fill = pattern)) +
  geom_col(show.legend = FALSE) +
  geom_text(aes(label = scales::comma(n)), hjust = -0.1, size = 3.5) +
  coord_flip() +
  theme_minimal(base_size = 12) +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title = "Seasonal regulatory patterns",
    subtitle = paste0(nrow(seasonal_categories), " predicted miRNA-mRNA interactions"),
    x = "",
    y = "Number of interactions"
  ) +
  theme(panel.grid.minor = element_blank())

print(p_summary)
ggsave("../output/Molecular/interactions/networks/seasonal_pattern_summary_barplot.pdf", width = 8, height = 5)

# ==========================================
# VISUALIZATION 2: Line trajectories (small multiples)
# ==========================================

# Get example interactions for each pattern (median trajectory)
# pattern_examples <- seasonal_categories %>%
#   group_by(pattern) %>%
#   # Get interactions closest to median correlation at each timepoint
#   mutate(
#     dist_from_median = abs(cor_TP0 - median(cor_TP0)) + 
#                        abs(cor_TP5_Ambient - median(cor_TP5_Ambient)) + 
#                        abs(cor_TP7_Ambient - median(cor_TP7_Ambient))
#   ) %>%
#   slice_min(dist_from_median, n = 100) %>%  # Top 50 most "typical" per pattern
#   ungroup()

# Reshape for plotting
trajectory_data <- seasonal_categories %>%
  select(pattern, miRNA, mRNA, cor_TP0, cor_TP5_Ambient, cor_TP7_Ambient) %>%
  pivot_longer(
    cols = c(cor_TP0, cor_TP5_Ambient, cor_TP7_Ambient),
    names_to = "timepoint",
    values_to = "correlation"
  ) %>%
  mutate(
    timepoint = recode(timepoint,
                      "cor_TP0" = "Feb",
                      "cor_TP5_Ambient" = "June", 
                      "cor_TP7_Ambient" = "Aug"),
    timepoint = factor(timepoint, levels = c("Feb", "June", "Aug")),
    interaction_id = paste(miRNA, mRNA, sep = "_")
  )

# Calculate mean trajectory per pattern
mean_trajectory <- trajectory_data %>%
  group_by(pattern, timepoint) %>%
  summarise(
    mean_cor = mean(correlation, na.rm = T),
    se_cor = sd(correlation, na.rm = T) / sqrt(n()),
    .groups = "drop")

# Plot
p_trajectories <- ggplot(trajectory_data, 
                         aes(x = timepoint, y = correlation, group = interaction_id)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50", linewidth = 0.3) +
  # Individual trajectories (faint)
  geom_line(alpha = 0.1, color = "gray30") +
  # Mean trajectory (bold)
  geom_line(data = mean_trajectory,
            aes(x = timepoint, y = mean_cor, group = 1),
            color = "red", linewidth = 1.5, inherit.aes = FALSE) +
  geom_point(data = mean_trajectory,
             aes(x = timepoint, y = mean_cor, group = 1),
             color = "red", size = 3, inherit.aes = FALSE) +
  # Ribbon for SE
  geom_ribbon(data = mean_trajectory,
              aes(x = timepoint, y = mean_cor,
                  ymin = mean_cor - se_cor, ymax = mean_cor + se_cor,
                  group = 1),
              alpha = 0.2, fill = "red", inherit.aes = FALSE) +
  facet_wrap(~pattern, ncol = 3) +
  theme_minimal(base_size = 11) +
  labs(
    title = "Seasonal trajectory patterns for miRNA-mRNA correlations",
    subtitle = "Red line = mean trajectory ± SE, gray lines = individual interactions",
    x = "Season",
    y = "Spearman correlation"
  ) +
  theme(
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold", size = 11)
  )

print(p_trajectories)
ggsave("../output/Molecular/interactions/networks/seasonal_pattern_trajectories.pdf", width = 12, height = 8)

# ==========================================
# VISUALIZATION 3: Heatmap (top dynamic interactions)
# ==========================================

# Get top 100 most dynamic interactions (by max_change)
top_dynamic <- seasonal_categories %>%
  arrange(desc(max_change)) %>%
  slice_head(n = 100) %>%
  mutate(
    interaction_label = paste0(miRNA, "→", substr(mRNA, 1, 20), "..."),
    interaction_label = fct_reorder(interaction_label, max_change)
  )

# Reshape for heatmap
heatmap_data <- top_dynamic %>%
  select(interaction_label, pattern, cor_TP0, cor_TP5_Ambient, cor_TP7_Ambient) %>%
  pivot_longer(
    cols = c(cor_TP0, cor_TP5_Ambient, cor_TP7_Ambient),
    names_to = "timepoint",
    values_to = "correlation"
  ) %>%
  mutate(
    timepoint = recode(timepoint,
                      "cor_TP0" = "Feb (TP0)",
                      "cor_TP5_Ambient" = "June (TP5)",
                      "cor_TP7_Ambient" = "Aug (TP7)"),
    timepoint = factor(timepoint, levels = c("Feb (TP0)", "June (TP5)", "Aug (TP7)"))
  )

p_heatmap <- ggplot(heatmap_data, aes(x = timepoint, y = interaction_label, fill = correlation)) +
  geom_tile(color = "white", linewidth = 0.1) +
  scale_fill_gradient2(
    low = "blue", mid = "white", high = "red",
    midpoint = 0,
    limits = c(-1, 1),
    name = "Correlation"
  ) +
  theme_minimal(base_size = 10) +
  labs(
    title = "Top 100 most dynamic miRNA-mRNA interactions",
    subtitle = "Ordered by magnitude of seasonal change",
    x = "Season",
    y = ""
  ) +
  theme(
    axis.text.y = element_text(size = 6),
    panel.grid = element_blank(),
    axis.text.x = element_text(angle = 0)
  )

print(p_heatmap)
ggsave("../output/Molecular/interactions/networks/seasonal_top100_dynamic_heatmap.pdf", width = 6, height = 14)

# ==========================================
# VISUALIZATION 4: Alluvial diagram (flow between categories)
# ==========================================

# Categorize correlations at each timepoint
alluvial_data <- seasonal_categories %>%
  dplyr::select(miRNA, mRNA, pattern, cor_TP0, cor_TP5_Ambient, cor_TP7_Ambient) %>%
  mutate(
    cat_TP0 = case_when(
      cor_TP0 < -0.5 ~ "Strong negative",
      cor_TP0 < 0 ~ "Weak negative",
      cor_TP0 < 0.5 ~ "Weak positive",
      TRUE ~ "Strong positive"
    ),
    cat_TP5 = case_when(
      cor_TP5_Ambient < -0.5 ~ "Strong negative",
      cor_TP5_Ambient < 0 ~ "Weak negative",
      cor_TP5_Ambient < 0.5 ~ "Weak positive",
      TRUE ~ "Strong positive"
    ),
    cat_TP7 = case_when(
      cor_TP7_Ambient < -0.5 ~ "Strong negative",
      cor_TP7_Ambient < 0 ~ "Weak negative",
      cor_TP7_Ambient < 0.5 ~ "Weak positive",
      TRUE ~ "Strong positive"
    )
  ) %>%
  # Count flows
  dplyr::count(cat_TP0, cat_TP5, cat_TP7, pattern)

# Set factor levels for ordering
cor_levels <- c("Strong negative", "Weak negative", "Weak positive", "Strong positive")

alluvial_data <- alluvial_data %>%
  mutate(
    cat_TP0 = factor(cat_TP0, levels = cor_levels),
    cat_TP5 = factor(cat_TP5, levels = cor_levels),
    cat_TP7 = factor(cat_TP7, levels = cor_levels)
  )

p_alluvial <- ggplot(alluvial_data,
                     aes(y = n, axis1 = cat_TP0, axis2 = cat_TP5, axis3 = cat_TP7)) +
  geom_alluvium(aes(fill = pattern), width = 1/12, alpha = 0.7) +
  geom_stratum(width = 1/12, fill = "gray80", color = "white") +
  geom_label(stat = "stratum", aes(label = after_stat(stratum)), size = 3) +
  scale_x_discrete(limits = c("Feb", "June", "Aug"), expand = c(.05, .05)) +
  scale_fill_brewer(palette = "Set2") +
  theme_minimal() +
  labs(
    title = "Flow of miRNA-mRNA correlations across seasons",
    subtitle = "How correlation categories change from winter to summer",
    y = "Number of interactions",
    fill = "Pattern"
  ) +
  theme(
    panel.grid = element_blank(),
    axis.text.y = element_blank()
  )

print(p_alluvial)
#ggsave("seasonal_flow_alluvial.pdf", width = 10, height = 7)

# ==========================================
# VISUALIZATION 5: Combined figure for manuscript
# ==========================================

# Combine the best plots into one figure
manuscript_figure <- (p_summary / p_trajectories) +
  plot_annotation(
    title = "Seasonal reorganization of miRNA-mRNA regulatory networks",
    tag_levels = "A",
    theme = theme(plot.title = element_text(size = 16, face = "bold"))
  )

print(manuscript_figure)
ggsave("../output/Molecular/interactions/networks/seasonal_patterns.pdf", width = 14, height = 12)

# Individual panels
#ggsave("FigureA_pattern_summary.pdf", plot = p_summary, width = 8, height = 5)
#ggsave("FigureB_trajectories.pdf", plot = p_trajectories, width = 12, height = 8)
```

Look at TREATMENT effects for JUNE
```{r}
# Subset T5 amb and heat 
# Get TP5 Ambient
tp5_ambient <- all_correlations_classified %>%
  filter(timepoint == "TP5", treatment == "Ambient") %>%
  select(miRNA, mRNA, pair_id, cor_TP5_Ambient = cor_value)

# Get TP5 Heat
tp5_heat <- all_correlations_classified %>%
  filter(timepoint == "TP5", treatment == "Heat") %>%
  select(miRNA, mRNA, pair_id, cor_TP5_Heat = cor_value)

# Combine - treatment patterns in June
tp5_pattern <- tp5_ambient %>%
  left_join(tp5_heat, by = c("miRNA", "mRNA", "pair_id")) %>%
  mutate(
    # Changes between treatments
    change_TP5amb_to_TP5heat = cor_TP5_Ambient - cor_TP5_Heat)

# Categorize the treatment patterns in June
tp5_categories <- tp5_pattern %>%
  filter(!is.na(change_TP5amb_to_TP5heat)) %>%
  mutate(
    pattern = case_when(
      # Big increase over treatment
      change_TP5amb_to_TP5heat > 0.7 ~ "Strong decrease",
      # Big decrease over treatment  
      change_TP5amb_to_TP5heat < -0.7 ~ "Strong increase",
      # Relatively stable
      change_TP5amb_to_TP5heat < 0.3 ~ "Stable",
      # Everything else
      TRUE ~ "Variable"
    )
  )

# Overall pattern distribution
tp5_pattern_summary <- tp5_categories %>%
  dplyr::count(pattern) %>%
  mutate(pattern = fct_reorder(pattern, n)) %>%
  ggplot(aes(x = pattern, y = n, fill = pattern)) +
  geom_col(show.legend = FALSE) +
  geom_text(aes(label = scales::comma(n)), hjust = -0.1, size = 3.5) +
  coord_flip() +
  theme_minimal(base_size = 12) +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title = "Seasonal regulatory patterns",
    subtitle = paste0(nrow(tp5_pattern_summary), " predicted miRNA-mRNA interactions"),
    x = "",
    y = "Number of interactions"
  ) +
  theme(panel.grid.minor = element_blank())

print(tp5_pattern_summary)
ggsave("../output/Molecular/interactions/networks/tp5_pattern_summary_barplot.pdf", width = 8, height = 5)

# Plot trajectories 
# Reshape for plotting
tp5_trajectory_data <- tp5_categories %>%
  select(pattern, miRNA, mRNA, cor_TP5_Ambient, cor_TP5_Heat) %>%
  pivot_longer(
    cols = c(cor_TP5_Ambient, cor_TP5_Heat),
    names_to = "timepoint",
    values_to = "correlation"
  ) %>%
  mutate(
    timepoint = recode(timepoint,
                      "cor_TP5_Ambient" = "June_Ambient", 
                      "cor_TP5_Heat" = "June_Heat" 

    #timepoint = factor(timepoint, levels = c("June_Ambient", "June_Heat")),
  )) %>%
  mutate(
    interaction_id = paste(miRNA, mRNA, sep = "_")
  )

# Calculate mean trajectory per pattern
tp5_mean_trajectory <- tp5_trajectory_data %>%
  group_by(pattern, timepoint) %>%
  summarise(
    mean_cor = mean(correlation, na.rm = T),
    se_cor = sd(correlation, na.rm = T) / sqrt(n()),
    .groups = "drop")

# Plot
tp5_p_trajectories <- ggplot(tp5_trajectory_data, 
                         aes(x = timepoint, y = correlation, group = interaction_id)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50", linewidth = 0.3) +
  # Individual trajectories (faint)
  geom_line(alpha = 0.1, color = "gray30") +
  # Mean trajectory (bold)
  geom_line(data = tp5_mean_trajectory,
            aes(x = timepoint, y = mean_cor, group = 1),
            color = "red", linewidth = 1.5, inherit.aes = FALSE) +
  geom_point(data = tp5_mean_trajectory,
             aes(x = timepoint, y = mean_cor, group = 1),
             color = "red", size = 3, inherit.aes = FALSE) +
  # Ribbon for SE
  geom_ribbon(data = tp5_mean_trajectory,
              aes(x = timepoint, y = mean_cor,
                  ymin = mean_cor - se_cor, ymax = mean_cor + se_cor,
                  group = 1),
              alpha = 0.2, fill = "red", inherit.aes = FALSE) +
  facet_wrap(~pattern, ncol = 3) +
  theme_minimal(base_size = 11) +
  labs(
    title = "June trajectory patterns for miRNA-mRNA correlations",
    subtitle = "Red line = mean trajectory ± SE, gray lines = individual interactions",
    x = "Treatment",
    y = "Spearman correlation"
  ) +
  theme(
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold", size = 11)
  )

print(tp5_p_trajectories)
ggsave("../output/Molecular/interactions/networks/tp5_pattern_trajectories.pdf", width = 12, height = 8)
```

Look at TREATMENT effects for AUGUST
```{r}
# Subset T7 amb and heat 
# Get TP7 Ambient
tp7_ambient <- all_correlations_classified %>%
  filter(timepoint == "TP7", treatment == "Ambient") %>%
  select(miRNA, mRNA, pair_id, cor_TP7_Ambient = cor_value)

# Get TP7 Heat
tp7_heat <- all_correlations_classified %>%
  filter(timepoint == "TP7", treatment == "Heat") %>%
  select(miRNA, mRNA, pair_id, cor_TP7_Heat = cor_value)

# Combine - treatment patterns in August
tp7_pattern <- tp7_ambient %>%
  left_join(tp7_heat, by = c("miRNA", "mRNA", "pair_id")) %>%
  mutate(
    # Changes between treatments
    change_TP7amb_to_TP7heat = cor_TP7_Ambient - cor_TP7_Heat)

# Categorize the treatment patterns in August 
tp7_categories <- tp7_pattern %>%
  filter(!is.na(change_TP7amb_to_TP7heat)) %>%
  mutate(
    pattern = case_when(
      # Big increase over treatment
      change_TP7amb_to_TP7heat > 0.7 ~ "Strong decrease",
      # Big decrease over treatment  
      change_TP7amb_to_TP7heat < -0.7 ~ "Strong increase",
      # Relatively stable
      change_TP7amb_to_TP7heat < 0.3 ~ "Stable",
      # Everything else
      TRUE ~ "Variable"
    )
  )

# Overall pattern distribution
tp7_pattern_summary <- tp7_categories %>%
  dplyr::count(pattern) %>%
  mutate(pattern = fct_reorder(pattern, n)) %>%
  ggplot(aes(x = pattern, y = n, fill = pattern)) +
  geom_col(show.legend = FALSE) +
  geom_text(aes(label = scales::comma(n)), hjust = -0.1, size = 3.5) +
  coord_flip() +
  theme_minimal(base_size = 12) +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title = "Seasonal regulatory patterns",
    subtitle = paste0(nrow(tp5_pattern_summary), " predicted miRNA-mRNA interactions"),
    x = "",
    y = "Number of interactions"
  ) +
  theme(panel.grid.minor = element_blank())

print(tp7_pattern_summary)
ggsave("../output/Molecular/interactions/networks/tp7_pattern_summary_barplot.pdf", width = 8, height = 5)

# Plot trajectories 
# Reshape for plotting
tp7_trajectory_data <- tp7_categories %>%
  select(pattern, miRNA, mRNA, cor_TP7_Ambient, cor_TP7_Heat) %>%
  pivot_longer(
    cols = c(cor_TP7_Ambient, cor_TP7_Heat),
    names_to = "timepoint",
    values_to = "correlation"
  ) %>%
  mutate(
    timepoint = recode(timepoint,
                      "cor_TP7_Ambient" = "August_Ambient", 
                      "cor_TP7_Heat" = "August_Heat" 

    #timepoint = factor(timepoint, levels = c("June_Ambient", "June_Heat")),
  )) %>%
  mutate(
    interaction_id = paste(miRNA, mRNA, sep = "_")
  )

# Calculate mean trajectory per pattern
tp7_mean_trajectory <- tp7_trajectory_data %>%
  group_by(pattern, timepoint) %>%
  summarise(
    mean_cor = mean(correlation, na.rm = T),
    se_cor = sd(correlation, na.rm = T) / sqrt(n()),
    .groups = "drop")

# Plot
tp7_p_trajectories <- ggplot(tp7_trajectory_data, 
                         aes(x = timepoint, y = correlation, group = interaction_id)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50", linewidth = 0.3) +
  # Individual trajectories (faint)
  geom_line(alpha = 0.1, color = "gray30") +
  # Mean trajectory (bold)
  geom_line(data = tp7_mean_trajectory,
            aes(x = timepoint, y = mean_cor, group = 1),
            color = "red", linewidth = 1.5, inherit.aes = FALSE) +
  geom_point(data = tp7_mean_trajectory,
             aes(x = timepoint, y = mean_cor, group = 1),
             color = "red", size = 3, inherit.aes = FALSE) +
  # Ribbon for SE
  geom_ribbon(data = tp7_mean_trajectory,
              aes(x = timepoint, y = mean_cor,
                  ymin = mean_cor - se_cor, ymax = mean_cor + se_cor,
                  group = 1),
              alpha = 0.2, fill = "red", inherit.aes = FALSE) +
  facet_wrap(~pattern, ncol = 3) +
  theme_minimal(base_size = 11) +
  labs(
    title = "August trajectory patterns for miRNA-mRNA correlations",
    subtitle = "Red line = mean trajectory ± SE, gray lines = individual interactions",
    x = "Treatment",
    y = "Spearman correlation"
  ) +
  theme(
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold", size = 11)
  )

print(tp7_p_trajectories)
ggsave("../output/Molecular/interactions/networks/tp7_pattern_trajectories.pdf", width = 12, height = 8)
```

Bipartite network anaysis (custom scripts). 
```{r custom functions for network calculations}
# Degree for "higher" level (rows): number of non-zero links per miRNA
miRNA_degree <- function(bp_matrix) {
  rowSums(bp_matrix > 0)
}

# Simple betweenness centrality on miRNA projection:
# 1) project bipartite matrix onto miRNAs: B = A %*% t(A)
# 2) compute betweenness on unweighted graph defined by B > 0
miRNA_betweenness <- function(bp_matrix) {
  A <- (bp_matrix > 0) * 1
  if (nrow(A) < 3) {
    return(setNames(rep(0, nrow(A)), rownames(A)))
  }
  B <- A %*% t(A)      # miRNA–miRNA projection (weighted)
  G <- (B > 0) * 1     # unweighted adjacency

  n <- nrow(G)
  bt <- numeric(n)
  names(bt) <- rownames(G)

  # Brandes-like betweenness for unweighted graphs
  for (s in seq_len(n)) {
    S <- integer(0)
    P <- vector("list", n)
    sigma <- rep(0, n); sigma[s] <- 1
    d <- rep(-1L, n); d[s] <- 0L

    Q <- c(s)
    while (length(Q) > 0) {
      v <- Q[1]; Q <- Q[-1]
      S <- c(S, v)
      nbrs <- which(G[v, ] != 0)
      for (w in nbrs) {
        if (d[w] < 0L) {
          d[w] <- d[v] + 1L
          Q <- c(Q, w)
        }
        if (d[w] == d[v] + 1L) {
          sigma[w] <- sigma[w] + sigma[v]
          P[[w]] <- c(P[[w]], v)
        }
      }
    }

    delta <- rep(0, n)
    while (length(S) > 0) {
      w <- S[length(S)]
      S <- S[-length(S)]
      for (v in P[[w]]) {
        if (sigma[w] > 0) {
          delta[v] <- delta[v] + (sigma[v] / sigma[w]) * (1 + delta[w])
        }
      }
      if (w != s) {
        bt[w] <- bt[w] + delta[w]
      }
    }
  }

  bt
}

# Blüthgen's d' specialization for miRNAs (rows).
# Treats entries >0 as interactions; uses information-theoretic formula.
miRNA_dprime <- function(bp_matrix) {
  A <- as.matrix(bp_matrix)
  A[A < 0] <- 0

  row_tot <- rowSums(A)
  col_tot <- colSums(A)
  Ttot <- sum(A)

  if (Ttot == 0 || all(row_tot == 0) || all(col_tot == 0)) {
    return(setNames(rep(NA_real_, nrow(A)), rownames(A)))
  }

  # p_ij: interaction probability per row
  p_ij <- sweep(A, 1, row_tot, FUN = "/")
  p_j  <- col_tot / Ttot

  dprime <- numeric(nrow(A))
  names(dprime) <- rownames(A)

  for (i in seq_len(nrow(A))) {
    if (row_tot[i] == 0) {
      dprime[i] <- NA_real_
      next
    }
    p_i <- p_ij[i, ]
    used <- p_i > 0 & p_j > 0
    if (!any(used)) {
      dprime[i] <- NA_real_
      next
    }

    # Kullback–Leibler divergence K_i
    Ki <- sum(p_i[used] * log(p_i[used] / p_j[used]))

    # approximate K_max for given p_j: perfect specialization
    # if all p_j[used] equal, Kmax can become 0 or NA, guard explicitly
    jstar <- which.min(p_j[used])
    p_star <- numeric(sum(used))
    p_star[jstar] <- 1

    # suppress warnings in case of 0*log(0/0)
    Kmax_vec <- suppressWarnings(p_star * log(p_star / p_j[used]))
    Kmax <- sum(Kmax_vec[is.finite(Kmax_vec)])

    if (is.na(Kmax) || Kmax <= 0) {
      dprime[i] <- NA_real_
    } else {
      dprime[i] <- Ki / Kmax
    }
  }

  dprime
}

create_bipartite_matrix_despard <- function(
  cor_data,
  timepoint_val,
  treatment_val,
  cor_threshold = 0.1
) {
  # Filter for this condition with strong correlations
  filtered_data <- cor_data %>%
    filter(
      timepoint == timepoint_val,
      treatment == treatment_val,
      !is.na(cor_value),
      abs(cor_value) >= cor_threshold
    ) %>%
    select(miRNA, mRNA) %>%
    distinct() %>%
    mutate(presence = 1) # Unweighted (presence/absence)

  if (nrow(filtered_data) == 0) {
    return(matrix(
      nrow = 0, ncol = 0,
      dimnames = list(character(0), character(0))
    ))
  }

  # Create matrix: rows = miRNAs (higher level), cols = mRNAs (lower level)
  bp_matrix <- filtered_data %>%
    pivot_wider(
      names_from  = mRNA,
      values_from = presence,
      values_fill = 0
    ) %>%
    column_to_rownames("miRNA") %>%
    as.matrix()

  bp_matrix
}
```

Create bipartite matrices
```{r}
bp_TP0 <- create_bipartite_matrix_despard(
  all_correlations_classified,
  "TP0", "Acclimation",
  cor_threshold = 0.1
)

bp_TP5_Ambient <- create_bipartite_matrix_despard(
  all_correlations_classified,
  "TP5", "Ambient",
  cor_threshold = 0.1
)

bp_TP5_Heat <- create_bipartite_matrix_despard(
  all_correlations_classified,
  "TP5", "Heat",
  cor_threshold = 0.1
)

bp_TP7_Ambient <- create_bipartite_matrix_despard(
  all_correlations_classified,
  "TP7", "Ambient",
  cor_threshold = 0.1
)

bp_TP7_Heat <- create_bipartite_matrix_despard(
  all_correlations_classified,
  "TP7", "Heat",
  cor_threshold = 0.1
)

bp_matrices_list <- list(
  "TP0_Acclimation" = bp_TP0,
  "TP5_Ambient"     = bp_TP5_Ambient,
  "TP5_Heat"        = bp_TP5_Heat,
  "TP7_Ambient"     = bp_TP7_Ambient,
  "TP7_Heat"        = bp_TP7_Heat
)

# Check dimensions
for (name in names(bp_matrices_list)) {
  cat(
    name, ":",
    nrow(bp_matrices_list[[name]]), "miRNAs x",
    ncol(bp_matrices_list[[name]]), "mRNAs,",
    sum(bp_matrices_list[[name]]), "interactions\n"
  )
}
```

Calculate network metrics (degree, betweenness, d') for each condition
```{r}
# TP0 Acclimation
deg_TP0 <- miRNA_degree(bp_TP0)
bt_TP0  <- miRNA_betweenness(bp_TP0)
dpr_TP0 <- miRNA_dprime(bp_TP0)

df_TP0 <- data.frame(
  condition   = "TP0_Acclimation",
  miRNA       = names(deg_TP0),
  degree      = as.numeric(deg_TP0),
  betweenness = as.numeric(bt_TP0[names(deg_TP0)]),
  dprime      = as.numeric(dpr_TP0[names(deg_TP0)]),
  row.names   = NULL)

# TP5 Ambient
deg_TP5_amb <- miRNA_degree(bp_TP5_Ambient)
bt_TP5_amb  <- miRNA_betweenness(bp_TP5_Ambient)
dpr_TP5_amb <- miRNA_dprime(bp_TP5_Ambient)

df_TP5_amb <- data.frame(
  condition   = "TP5_Ambient",
  miRNA       = names(deg_TP5_amb),
  degree      = as.numeric(deg_TP5_amb),
  betweenness = as.numeric(bt_TP5_amb[names(deg_TP5_amb)]),
  dprime      = as.numeric(dpr_TP5_amb[names(deg_TP5_amb)]),
  row.names   = NULL)

# TP5 Heat
deg_TP5_heat <- miRNA_degree(bp_TP5_Heat)
bt_TP5_heat  <- miRNA_betweenness(bp_TP5_Heat)
dpr_TP5_heat <- miRNA_dprime(bp_TP5_Heat)

df_TP5_heat <- data.frame(
  condition   = "TP5_Heat",
  miRNA       = names(deg_TP5_heat),
  degree      = as.numeric(deg_TP5_heat),
  betweenness = as.numeric(bt_TP5_heat[names(deg_TP5_heat)]),
  dprime      = as.numeric(dpr_TP5_heat[names(deg_TP5_heat)]),
  row.names   = NULL)

# TP7 Ambient
deg_TP7_amb <- miRNA_degree(bp_TP7_Ambient)
bt_TP7_amb  <- miRNA_betweenness(bp_TP7_Ambient)
dpr_TP7_amb <- miRNA_dprime(bp_TP7_Ambient)

df_TP7_amb <- data.frame(
  condition   = "TP7_Ambient",
  miRNA       = names(deg_TP7_amb),
  degree      = as.numeric(deg_TP7_amb),
  betweenness = as.numeric(bt_TP7_amb[names(deg_TP7_amb)]),
  dprime      = as.numeric(dpr_TP7_amb[names(deg_TP7_amb)]),
  row.names   = NULL)

# TP7 Heat
deg_TP7_heat <- miRNA_degree(bp_TP7_Heat)
bt_TP7_heat  <- miRNA_betweenness(bp_TP7_Heat)
dpr_TP7_heat <- miRNA_dprime(bp_TP7_Heat)

df_TP7_heat <- data.frame(
  condition   = "TP7_Heat",
  miRNA       = names(deg_TP7_heat),
  degree      = as.numeric(deg_TP7_heat),
  betweenness = as.numeric(bt_TP7_heat[names(deg_TP7_heat)]),
  dprime      = as.numeric(dpr_TP7_heat[names(deg_TP7_heat)]),
  row.names   = NULL)

network_metrics <- rbind(df_TP0, df_TP5_amb, df_TP7_amb, df_TP5_heat, df_TP7_heat)
```

Summarize network metrics 
```{r}
network_metrics_summary <- network_metrics %>%
  group_by(condition) %>%
  summarise(
    n_miRNAs = n(),
    mean_degree = mean(degree, na.rm = TRUE),
    sd_degree = sd(degree, na.rm = TRUE),
    sem_degree = sd(degree, na.rm = TRUE) / sqrt(sum(!is.na(degree))),
    min_degree = min(degree, na.rm = TRUE),
    max_degree = max(degree, na.rm = TRUE), 
    median_degree = median(degree, na.rm = TRUE),
    mean_betweenness = mean(betweenness, na.rm = TRUE),
    sd_betweenness = sd(betweenness, na.rm = TRUE),
    sem_betweenness = sd(betweenness, na.rm = TRUE) / sqrt(sum(!is.na(betweenness))),
    min_betweenness = min(betweenness, na.rm = TRUE),
    max_betweenness = max(betweenness, na.rm = TRUE), 
    median_betweenness = median(betweenness, na.rm = TRUE),
    mean_dprime = mean(dprime, na.rm = TRUE),
    sd_dprime = sd(dprime, na.rm = TRUE),
    sem_dprime = sd(dprime, na.rm = TRUE) / sqrt(sum(!is.na(dprime))),
    min_dprime = min(dprime, na.rm = TRUE),
    max_dprime = max(dprime, na.rm = TRUE), 
    median_dprime = median(dprime, na.rm = TRUE),
    .groups = "drop")
```

Plot seasonal
```{r}
# Subset ambient only 
seasonal_network_metrics_summary <- network_metrics_summary %>%
  filter(condition %in% c("TP0_Acclimation", "TP5_Ambient", "TP7_Ambient"))

# Set levels 
seasonal_network_metrics_summary$condition <- factor(seasonal_network_metrics_summary$condition, levels = c("TP0_Acclimation", "TP5_Ambient", "TP7_Ambient"))

# 1. DEGREE plot
p_degree <- ggplot(seasonal_network_metrics_summary, aes(x = condition, y = mean_degree)) +
  geom_point(size = 4, color = "steelblue", fill = "steelblue") +
  geom_errorbar(aes(ymin = mean_degree - sem_degree, ymax = mean_degree + sem_degree),
                width = 0.2, size = 1, color = "steelblue") +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(
    x = "Condition", 
    y = "Mean degree",
    title = "Mean miRNA degree across seasonal timepoints",
    subtitle = "Dots show means, error bars show SEM"
  )
print(p_degree)
#ggsave("seasonal_degree_individual.pdf", width = 7, height = 5)

# 2. BETWEENNESS plot
p_betweenness <- ggplot(seasonal_network_metrics_summary, aes(x = condition, y = mean_betweenness)) +
  geom_point(size = 4, color = "steelblue", fill = "steelblue") +
  geom_errorbar(aes(ymin = mean_betweenness - sem_betweenness, ymax = mean_betweenness + sem_betweenness),
                width = 0.2, size = 1, color = "steelblue") +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(
    x = "Condition", 
    y = "Mean betweenness",
    title = "Mean miRNA betweenness across seasonal timepoints",
    subtitle = "Dots show means, error bars show SEM"
  )
print(p_betweenness)
#ggsave("seasonal_betweenness_individual.pdf", width = 7, height = 5)

# 3. D' plot  
p_dprime <- ggplot(seasonal_network_metrics_summary, aes(x = condition, y = mean_dprime)) +
  geom_point(size = 4, color = "steelblue", fill = "steelblue") +
  geom_errorbar(aes(ymin = mean_dprime - sd_dprime/sqrt(n_miRNAs), 
                    ymax = mean_dprime + sd_dprime/sqrt(n_miRNAs)),
                width = 0.2, size = 1, color = "steelblue") +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(
    x = "Condition", 
    y = "Mean d' (specialization)",
    title = "Mean miRNA specialization (d') across seasonal timepoints",
    subtitle = "Dots show means, error bars show SEM"
  )
print(p_dprime)
#ggsave("seasonal_dprime_individual.pdf", width = 7, height = 5)
```

Different plots for seasonal 
```{r}
# Subset ambient only 
seasonal_network_metrics <- network_metrics %>%
  filter(condition %in% c("TP0_Acclimation", "TP5_Ambient", "TP7_Ambient"))

# Ensure condition is ordered chronologically
seasonal_network_metrics <- seasonal_network_metrics %>%
  mutate(condition = factor(condition, 
                           levels = c("TP0_Acclimation", "TP5_Ambient", "TP7_Ambient")))

# 1. DEGREE boxplot (individual miRNAs)
p_degree_raw <- ggplot(seasonal_network_metrics, aes(x = condition, y = degree, fill = condition)) +
  geom_boxplot(alpha = 0.7, outlier.shape = 21, outlier.size = 1.5, outlier.fill = "white") +
  scale_fill_manual(values = c("TP0_Acclimation" = "#E69F00", 
                              "TP5_Ambient" = "#56B4E9", 
                              "TP7_Ambient" = "#009E73")) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Condition", 
       y = "Degree (number of mRNA targets)",
       title = "miRNA degree distribution across seasonal timepoints")

print(p_degree_raw)
#ggsave("miRNA_degree_boxplot.pdf", width = 7, height = 6)

# 2. BETWEENNESS boxplot
p_betweenness_raw <- ggplot(seasonal_network_metrics, aes(x = condition, y = betweenness, fill = condition)) +
  geom_boxplot(alpha = 0.7, outlier.shape = 21, outlier.size = 1.5, outlier.fill = "white") +
  scale_fill_manual(values = c("TP0_Acclimation" = "#E69F00", 
                              "TP5_Ambient" = "#56B4E9", 
                              "TP7_Ambient" = "#009E73")) +
  scale_y_log10() +  # log scale for betweenness
  theme_minimal(base_size = 12) +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Condition", 
       y = "Betweenness centrality (log scale)",
       title = "miRNA betweenness distribution across seasonal timepoints")

print(p_betweenness_raw)
#ggsave("miRNA_betweenness_boxplot.pdf", width = 7, height = 6)

# 3. D' boxplot
p_dprime_raw <- ggplot(seasonal_network_metrics, aes(x = condition, y = dprime, fill = condition)) +
  geom_boxplot(alpha = 0.7, outlier.shape = 21, outlier.size = 1.5, outlier.fill = "white") +
  scale_fill_manual(values = c("TP0_Acclimation" = "#E69F00", 
                              "TP5_Ambient" = "#56B4E9", 
                              "TP7_Ambient" = "#009E73")) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Condition", 
       y = "Specialization index (d')",
       title = "miRNA specialization (d') distribution across seasonal timepoints")

print(p_dprime_raw)
#ggsave("miRNA_dprime_boxplot.pdf", width = 7, height = 6)

# 1. DEGREE violin plot
p_degree_violin <- ggplot(seasonal_network_metrics, aes(x = condition, y = degree, fill = condition)) +
  geom_violin(alpha = 0.7, trim = FALSE) +
  geom_boxplot(width = 0.15, fill = "white", outlier.alpha = 0) +
  scale_fill_manual(values = c("TP0_Acclimation" = "#E69F00", 
                              "TP5_Ambient" = "#56B4E9", 
                              "TP7_Ambient" = "#009E73")) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Condition", 
       y = "Degree (number of mRNA targets)",
       title = "miRNA degree distribution across seasonal timepoints")

print(p_degree_violin)

# 2. BETWEENNESS violin plot (log scale)
p_betweenness_violin <- ggplot(seasonal_network_metrics, aes(x = condition, y = betweenness, fill = condition)) +
  geom_violin(alpha = 0.7, trim = FALSE) +
  geom_boxplot(width = 0.15, fill = "white", outlier.alpha = 0) +
  scale_fill_manual(values = c("TP0_Acclimation" = "#E69F00", 
                              "TP5_Ambient" = "#56B4E9", 
                              "TP7_Ambient" = "#009E73")) +
  scale_y_log10() +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Condition", 
       y = "Betweenness centrality (log scale)",
       title = "miRNA betweenness distribution across seasonal timepoints")

print(p_betweenness_violin)

# 3. D' violin plot
p_dprime_violin <- ggplot(seasonal_network_metrics, aes(x = condition, y = dprime, fill = condition)) +
  geom_violin(alpha = 0.7, trim = FALSE) +
  geom_boxplot(width = 0.15, fill = "white", outlier.alpha = 0) +
  scale_fill_manual(values = c("TP0_Acclimation" = "#E69F00", 
                              "TP5_Ambient" = "#56B4E9", 
                              "TP7_Ambient" = "#009E73")) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Condition", 
       y = "Specialization index (d')",
       title = "miRNA specialization (d') distribution across seasonal timepoints")

print(p_dprime_violin)
```


